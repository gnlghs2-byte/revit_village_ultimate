<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ—ï¸ Revit ë¹Œë¦¬ì§€ ì–¼í‹°ë°‹ - BIM ë©”íƒ€ë²„ìŠ¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Malgun Gothic', sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #ffeaa7 0%, #fab1a0 100%);
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.15);
            pointer-events: all;
            min-width: 320px;
            border: 3px solid rgba(255, 192, 203, 0.5);
        }

        #hud h2 {
            color: #ff6b9d;
            margin-bottom: 18px;
            font-size: 28px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .character-selector {
            display: flex;
            gap: 12px;
            margin: 18px 0;
        }

        .character-btn {
            padding: 14px 24px;
            border: 3px solid #ffd93d;
            border-radius: 15px;
            cursor: pointer;
            background: linear-gradient(135deg, #fff 0%, #ffe6f0 100%);
            transition: all 0.3s;
            font-size: 18px;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .character-btn:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(255, 107, 157, 0.3);
        }

        .character-btn.active {
            background: linear-gradient(135deg, #ff6b9d 0%, #ffa07a 100%);
            color: white;
            border-color: #ff6b9d;
        }

        .controls-info {
            background: linear-gradient(135deg, #fff5e6 0%, #ffe4e1 100%);
            padding: 18px;
            border-radius: 15px;
            margin-top: 18px;
            font-size: 15px;
            line-height: 2;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .controls-info strong {
            color: #ff6b9d;
            font-size: 16px;
        }

        #toolbar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 20px 35px;
            border-radius: 25px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.15);
            pointer-events: all;
            display: flex;
            gap: 20px;
            align-items: center;
            border: 3px solid rgba(255, 192, 203, 0.5);
        }

        .tool-btn {
            padding: 14px 28px;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 700;
            transition: all 0.3s;
            background: linear-gradient(135deg, #ffd93d 0%, #ffbe76 100%);
            color: #8b4513;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .tool-btn:hover {
            transform: scale(1.1) translateY(-3px);
            box-shadow: 0 8px 25px rgba(255, 190, 118, 0.4);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #ff6b9d 0%, #ffa07a 100%);
            color: white;
        }

        .block-palette {
            display: flex;
            gap: 12px;
        }

        .block-option {
            width: 60px;
            height: 60px;
            border: 4px solid white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .block-option:hover {
            transform: scale(1.15) translateY(-5px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .block-option.active {
            border-color: #ff6b9d;
            box-shadow: 0 0 20px rgba(255, 107, 157, 0.6);
            transform: scale(1.2);
        }

        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 240px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.15);
            pointer-events: all;
            overflow: hidden;
            border: 3px solid rgba(255, 192, 203, 0.5);
        }

        #minimap h3 {
            text-align: center;
            padding: 12px;
            margin: 0;
            background: linear-gradient(135deg, #ff6b9d 0%, #ffa07a 100%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        #minimapCanvas {
            display: block;
            width: 100%;
            height: calc(100% - 48px);
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .spinner {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid #ff6b9d;
            border-radius: 50%;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #loading h1 {
            font-size: 42px;
            color: white;
            margin-bottom: 15px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.2);
        }

        #loading p {
            font-size: 22px;
            color: white;
            opacity: 0.9;
        }

        /* 3D ëª¨ë¸ íŒ¨ë„ */
        #modelPanel {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.15);
            pointer-events: all;
            min-width: 400px;
            border: 3px solid rgba(255, 192, 203, 0.5);
        }

        #modelPanel h3 {
            color: #ff6b9d;
            margin-bottom: 10px;
            font-size: 22px;
        }

        #modelPanel h4 {
            color: #667eea;
            margin: 15px 0 10px 0;
            font-size: 16px;
        }

        #modelFileInput {
            width: 100%;
            padding: 10px;
            border: 2px solid #ffd93d;
            border-radius: 10px;
            cursor: pointer;
            background: white;
        }

        #modelControls {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #fff5e6 0%, #ffe4e1 100%);
            border-radius: 15px;
        }

        #modelControls label {
            display: block;
            margin: 10px 0;
            font-weight: 600;
            color: #667eea;
        }

        #modelControls input[type="range"] {
            width: 100%;
            margin-top: 5px;
        }

        #modelControls button {
            margin: 10px 5px 0 0;
        }

        #modelList {
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        #modelList ul {
            list-style: none;
            padding: 0;
        }

        #modelList li {
            padding: 8px 12px;
            margin: 5px 0;
            background: #f0f0f0;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #modelList button {
            padding: 5px 10px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background: #ff6b6b;
            color: white;
            font-size: 12px;
        }

        /* ğŸ¯ TPS ìŠˆíŒ… ì‹œìŠ¤í…œ */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 200;
            display: none; /* ì „íˆ¬ ëª¨ë“œì—ì„œë§Œ í‘œì‹œ */
        }

        #crosshair.active {
            display: block;
        }

        /* ì‹­ìí˜• ì¡°ì¤€ì  */
        .crosshair-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #ff6b9d;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff6b9d, 0 0 20px #ff6b9d;
            animation: pulse 1.5s ease-in-out infinite;
        }

        .crosshair-line {
            position: absolute;
            background: rgba(255, 107, 157, 0.8);
            box-shadow: 0 0 5px rgba(255, 107, 157, 0.5);
        }

        .crosshair-line.top {
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 10px;
        }

        .crosshair-line.bottom {
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 10px;
        }

        .crosshair-line.left {
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 2px;
        }

        .crosshair-line.right {
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            width: 10px;
            height: 2px;
        }

        @keyframes pulse {
            0%, 100% { 
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 0.7;
                transform: translate(-50%, -50%) scale(1.2);
            }
        }

        /* ì „íˆ¬ ëª¨ë“œ í‘œì‹œ */
        #combatMode {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 107, 157, 0.95);
            padding: 15px 25px;
            border-radius: 15px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 5px 20px rgba(255, 107, 157, 0.4);
            display: none;
            pointer-events: none;
        }

        #combatMode.active {
            display: block;
            animation: combatPulse 1s ease-in-out infinite;
        }

        @keyframes combatPulse {
            0%, 100% { box-shadow: 0 5px 20px rgba(255, 107, 157, 0.4); }
            50% { box-shadow: 0 5px 30px rgba(255, 107, 157, 0.8); }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <h1>ğŸ—ï¸ Revit ë¹Œë¦¬ì§€ ì–¼í‹°ë°‹</h1>
        <p>BIM ë©”íƒ€ë²„ìŠ¤ë¥¼ ì¤€ë¹„í•˜ëŠ” ì¤‘...</p>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-overlay">
        <div id="hud">
            <h2>ğŸ—ï¸ Revit ë¹Œë¦¬ì§€</h2>
            <div>
                <strong>ìºë¦­í„° ì„ íƒ:</strong>
                <div class="character-selector">
                    <button class="character-btn active" data-char="ryan">ğŸ¦ ë¼ì´ì–¸</button>
                    <button class="character-btn" data-char="muzi">ğŸ° ë¬´ì§€</button>
                    <button class="character-btn" data-char="apeach">ğŸ‘ ì–´í”¼ì¹˜</button>
                </div>
            </div>
            <div class="controls-info">
                <strong>âŒ¨ï¸ ì¡°ì‘ë²•:</strong><br>
                â€¢ <strong>W A S D</strong> - ìºë¦­í„° ì´ë™<br>
                â€¢ <strong>ìš°í´ë¦­ ë“œë˜ê·¸</strong> - ì¹´ë©”ë¼ íšŒì „<br>
                â€¢ <strong>ìŠ¤í¬ë¡¤</strong> - ì¤Œ ì¸/ì•„ì›ƒ<br>
                â€¢ <strong>ì¢Œí´ë¦­</strong> - ë¸”ë¡ ë°°ì¹˜ / ğŸ”« ë°œì‚¬<br>
                â€¢ <strong>Space</strong> - ì í”„<br>
                â€¢ <strong>Q</strong> - ì „íˆ¬ ëª¨ë“œ ì „í™˜
            </div>
        </div>

        <div id="minimap">
            <h3>ğŸ—ºï¸ ë§ˆì„ ì§€ë„</h3>
            <canvas id="minimapCanvas" width="234" height="192"></canvas>
        </div>

        <!-- ğŸ¯ ì¡°ì¤€ì  (Crosshair) -->
        <div id="crosshair">
            <div class="crosshair-center"></div>
            <div class="crosshair-line top"></div>
            <div class="crosshair-line bottom"></div>
            <div class="crosshair-line left"></div>
            <div class="crosshair-line right"></div>
        </div>

        <!-- ğŸ”« ì „íˆ¬ ëª¨ë“œ í‘œì‹œ -->
        <div id="combatMode">ğŸ”« ì „íˆ¬ ëª¨ë“œ</div>

        <div id="toolbar">
            <button class="tool-btn active" id="buildMode">ğŸ”¨ ë¸”ë¡ ëª¨ë“œ</button>
            <button class="tool-btn" id="removeMode">ğŸ—‘ï¸ ì œê±° ëª¨ë“œ</button>
            <button class="tool-btn" id="combatModeBtn">ğŸ”« ì „íˆ¬ ëª¨ë“œ</button>
            <button class="tool-btn" id="modelMode">ğŸ  3D ëª¨ë¸</button>
            <div class="block-palette">
                <div class="block-option active" data-block="grass" style="background: linear-gradient(135deg, #7ec850 0%, #6ba83c 100%);" title="ì”ë””"></div>
                <div class="block-option" data-block="wood" style="background: linear-gradient(135deg, #d2691e 0%, #8b4513 100%);" title="ë‚˜ë¬´"></div>
                <div class="block-option" data-block="stone" style="background: linear-gradient(135deg, #c0c0c0 0%, #909090 100%);" title="ëŒ"></div>
                <div class="block-option" data-block="brick" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);" title="ë²½ëŒ"></div>
            </div>
        </div>

        <!-- 3D ëª¨ë¸ ì„í¬íŠ¸ íŒ¨ë„ -->
        <div id="modelPanel" style="display: none;">
            <h3>ğŸ—ï¸ 3D ëª¨ë¸ ê°€ì ¸ì˜¤ê¸°</h3>
            <p style="font-size: 14px; color: #666; margin: 10px 0;">Revit, 3ds Max, SketchUp, Rhino íŒŒì¼</p>
            <input type="file" id="modelFileInput" accept=".obj,.glb,.gltf" style="margin: 15px 0;">
            <div id="modelControls" style="display: none;">
                <h4>ëª¨ë¸ ì¡°ì ˆ:</h4>
                <label>í¬ê¸°: <input type="range" id="modelScale" min="0.1" max="10" step="0.1" value="1"></label>
                <label>íšŒì „: <input type="range" id="modelRotation" min="0" max="360" step="1" value="0"></label>
                <button class="tool-btn" id="placeModel">ë°°ì¹˜í•˜ê¸°</button>
                <button class="tool-btn" id="cancelModel">ì·¨ì†Œ</button>
            </div>
            <div id="modelList">
                <h4>ë¶ˆëŸ¬ì˜¨ ëª¨ë¸:</h4>
                <ul id="loadedModels"></ul>
            </div>
        </div>
    </div>

    <!-- Three.js ES Module ë°©ì‹ (ìµœì‹  ë¡œë” ì§€ì›) -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        // ============================================
        // ğŸ—ï¸ Revit ë¹Œë¦¬ì§€ ì–¼í‹°ë°‹ - BIM ë©”íƒ€ë²„ìŠ¤
        // ============================================
        
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        
        class CozyVillageGame {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.player = null;
                this.currentCharacter = 'ryan';
                this.buildMode = true;
                this.selectedBlock = 'grass';
                
                // âŒ¨ï¸ WASD í‚¤ ìƒíƒœ (KeyboardEvent.code ê¸°ë°˜)
                this.keyState = {
                    KeyW: false,
                    KeyA: false,
                    KeyS: false,
                    KeyD: false,
                    Space: false
                };
                this.mouseDown = false;
                this.mousePos = { x: 0, y: 0 };
                
                // ğŸ® TPS ì¹´ë©”ë¼ ì‹œìŠ¤í…œ
                this.cameraOffset = new THREE.Vector3(0.5, 2, -3); // ìˆ„ë”ë·° ì˜¤í”„ì…‹
                this.cameraDistance = 5; // ìºë¦­í„°ì™€ì˜ ê±°ë¦¬
                this.cameraAngle = { horizontal: 0, vertical: 0.3 }; // ìˆ˜í‰/ìˆ˜ì§ ê°ë„
                this.cameraTarget = new THREE.Vector3();
                this.cameraLookAt = new THREE.Vector3();
                
                // ğŸƒ ë¬¼ë¦¬ ê¸°ë°˜ ì´ë™
                this.velocity = new THREE.Vector3();
                this.acceleration = 0.02; // ê°€ì†ë„
                this.maxSpeed = 0.15; // ìµœëŒ€ ì†ë„
                this.friction = 0.85; // ë§ˆì°°ë ¥ (ê°ì†)
                this.targetRotation = 0; // ëª©í‘œ íšŒì „ ê°ë„
                
                // ì í”„ ì‹œìŠ¤í…œ
                this.isGrounded = true;
                this.jumpVelocity = 0;
                this.gravity = 0.02;
                this.jumpPower = 0.35;
                
                this.world = new Map();
                this.gridSize = 1;
                this.villageSize = 200;
                this.buildings = [];
                
                // ğŸ—ï¸ BIM 3D ëª¨ë¸ ì‹œìŠ¤í…œ
                this.loadedModels = [];
                this.currentModel = null;
                this.modelPreview = null;
                this.modelScale = 1;
                this.modelRotation = 0;
                this.modelHeight = 0;
                this.gltfLoader = new GLTFLoader();
                this.objLoader = new OBJLoader();
                
                // ì• ë‹ˆë©”ì´ì…˜
                this.time = 0;
                this.playerBounce = 0;
                
                // ğŸ”« TPS ìŠˆíŒ… ì‹œìŠ¤í…œ
                this.combatMode = false; // ì „íˆ¬ ëª¨ë“œ (false = ê±´ì¶•, true = ì „íˆ¬)
                this.weapon = null; // ë¬´ê¸° ì˜¤ë¸Œì íŠ¸
                this.bullets = []; // ë°œì‚¬ëœ ì´ì•Œ ë°°ì—´
                this.bulletSpeed = 1.0; // ì´ì•Œ ì†ë„ (ë¹ ë¥´ê²Œ!)
                this.bulletLifetime = 2000; // ì´ì•Œ ìƒëª… ì‹œê°„ (2ì´ˆ)
                this.lastShotTime = 0; // ë§ˆì§€ë§‰ ë°œì‚¬ ì‹œê°„
                this.fireRate = 150; // ë°œì‚¬ ê°„ê²© (ms)
                
                // ğŸ‘¾ ëª¬ìŠ¤í„°(ìŠ¬ë¼ì„) ì‹œìŠ¤í…œ
                this.monsters = []; // ëª¬ìŠ¤í„° ë°°ì—´
                this.monsterCount = 8; // ìŠ¬ë¼ì„ ê°œìˆ˜
                
                // ğŸ”Š Web Audio API (íš¨ê³¼ìŒ)
                this.audioContext = null; // AudioContext (ì´ˆê¸°í™” ì‹œ ìƒì„±)
                
                this.init();
            }

            init() {
                try {
                    console.log('ğŸ¨ ê³ í’ˆì§ˆ ë§ˆì„ ì´ˆê¸°í™” ì¤‘...');
                    
                    if (typeof THREE === 'undefined') {
                        throw new Error('Three.js ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    }
                    
                    this.setupScene();
                    this.setupLights();
                this.setupGround();
                this.createPlayer();
                this.createWeapon(); // ğŸ”« ë¬´ê¸° ìƒì„±
                this.setupAudio(); // ğŸ”Š ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ
                this.spawnMonsters(); // ğŸ‘¾ ìŠ¬ë¼ì„ ì†Œí™˜
                this.setupControls();
                this.setupModelLoaders();
                this.animate();
                    
                    console.log('âœ… ì´ˆê¸°í™” ì™„ë£Œ!');
                    
                    setTimeout(() => {
                        document.getElementById('loading').style.display = 'none';
                    }, 1500);
                    
                } catch (error) {
                    console.error('âŒ ì˜¤ë¥˜:', error);
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                
                // âœ¨ íŒŒìŠ¤í…”í†¤ í•˜ëŠ˜ìƒ‰ ë°°ê²½
                this.scene.background = new THREE.Color(0x87CEEB);
                
                // âœ¨ ë¶€ë“œëŸ¬ìš´ ì•ˆê°œ íš¨ê³¼ (ì›ê²½ í˜ì´ë“œ)
                this.scene.fog = new THREE.Fog(0xa8dadc, 80, 250);

                this.camera = new THREE.PerspectiveCamera(
                    65,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );

                const canvas = document.getElementById('gameCanvas');
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: canvas, 
                    antialias: true // ë¶€ë“œëŸ¬ìš´ ì—£ì§€
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                
                // âœ¨ HIGH-FIDELITY ë Œë”ëŸ¬ ì„¤ì •
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap; // ë¶€ë“œëŸ¬ìš´ ê·¸ë¦¼ì
                this.renderer.outputColorSpace = THREE.SRGBColorSpace; // ì„ ëª…í•œ ìƒ‰ê°
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.1;

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            setupLights() {
                // âœ¨ 1. HemisphereLight - í•˜ëŠ˜ê³¼ ë•…ì˜ ë°˜ì‚¬ê´‘ (ë”°ëœ»í•œ ë² ì´ìŠ¤)
                const hemisphereLight = new THREE.HemisphereLight(
                    0xffffbb, // í•˜ëŠ˜ - ë”°ëœ»í•œ í¬ë¦¼ìƒ‰
                    0x7ec850, // ë•… - ë¶€ë“œëŸ¬ìš´ ì´ˆë¡
                    0.7
                );
                this.scene.add(hemisphereLight);

                // âœ¨ 2. DirectionalLight - íƒœì–‘ê´‘ (ê·¸ë¦¼ì ìƒì„±)
                const sunLight = new THREE.DirectionalLight(0xfff5e6, 1.3);
                sunLight.position.set(80, 120, 60);
                sunLight.castShadow = true;
                
                // ê³ í•´ìƒë„ ê·¸ë¦¼ì ì„¤ì •
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sunLight.shadow.camera.left = -120;
                sunLight.shadow.camera.right = 120;
                sunLight.shadow.camera.top = 120;
                sunLight.shadow.camera.bottom = -120;
                sunLight.shadow.camera.near = 0.5;
                sunLight.shadow.camera.far = 500;
                sunLight.shadow.bias = -0.0001;
                sunLight.shadow.normalBias = 0.02;
                
                this.scene.add(sunLight);

                // âœ¨ 3. ë¶€ë“œëŸ¬ìš´ ì£¼ë³€ê´‘
                const ambientLight = new THREE.AmbientLight(0xffeedd, 0.4);
                this.scene.add(ambientLight);
                
                // âœ¨ 4. ì¤‘ì•™ ì±„ìš°ê¸° ì¡°ëª… (í¬ê·¼í•¨ ê°•í™”)
                const fillLight = new THREE.PointLight(0xffd9b3, 0.3, 50);
                fillLight.position.set(0, 20, 0);
                this.scene.add(fillLight);
            }

            setupGround() {
                console.log('ğŸ—ï¸ ì•„ëŠ‘í•œ ë§ˆì„ ìƒì„± ì¤‘...');
                
                // ë°”ë‹¥
                this.createCozyTerrain();
                
                // ì¤‘ì•™ ê´‘ì¥
                this.createCozyPlaza();
                
                // ê¸¸
                this.createPaths();
                
                // ê±´ë¬¼ë“¤
                this.createCozyBuildings();
                
                // ìì—° í™˜ê²½
                this.createCozyNature();
                
                // ì¥ì‹ë“¤
                this.createDecorations();
                
                console.log('âœ… ë§ˆì„ ìƒì„± ì™„ë£Œ!');
            }

            createCozyTerrain() {
                // ğŸŒ¿ ì”ë”” ëŠë‚Œì˜ í…ìŠ¤ì²˜ ë°”ë‹¥ (ê²©ì íŒ¨í„´)
                const groundSize = this.villageSize;
                const tileSize = 10;
                
                for (let x = -groundSize/2; x < groundSize/2; x += tileSize) {
                    for (let z = -groundSize/2; z < groundSize/2; z += tileSize) {
                        const distFromCenter = Math.sqrt(x*x + z*z);
                        
                        // ì±„ë„ ë†’ì€ ì”ë”” ìƒ‰ìƒ
                        let color;
                        if (distFromCenter < 45) {
                            color = 0xf5deb3; // ì¤‘ì•™ ê´‘ì¥ - ë°ì€ ëª¨ë˜ìƒ‰
                        } else if (distFromCenter < 90) {
                            color = 0x8fbc8f; // ì”ë””
                        } else {
                            color = 0x6b8e23; // ì§™ì€ ìˆ²
                        }
                        
                        // âœ¨ MeshStandardMaterial ì‚¬ìš© (ë¹› ë°˜ì‘)
                        const tile = new THREE.Mesh(
                            new THREE.BoxGeometry(tileSize, 0.3, tileSize),
                            new THREE.MeshStandardMaterial({ 
                                color: color,
                                roughness: 0.9,
                                metalness: 0.1
                            })
                        );
                        tile.position.set(x + tileSize/2, -0.15, z + tileSize/2);
                        tile.receiveShadow = true;
                        this.scene.add(tile);
                    }
                }
                
                // ì€ì€í•œ ê·¸ë¦¬ë“œ í—¬í¼
                const grid = new THREE.GridHelper(groundSize, 50, 0x999999, 0xdddddd);
                grid.position.y = 0.02;
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                this.scene.add(grid);
            }

            createCozyPlaza() {
                // í™”ë ¤í•œ ë¶„ìˆ˜ëŒ€
                const fountain = new THREE.Group();
                
                const base = new THREE.Mesh(
                    new THREE.CylinderGeometry(6, 7, 1.5, 20),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffe4e1,
                        roughness: 0.4,
                        metalness: 0.3
                    })
                );
                base.position.y = 0.75;
                base.castShadow = true;
                base.receiveShadow = true;
                fountain.add(base);
                
                // ë¬¼
                const water = new THREE.Mesh(
                    new THREE.CylinderGeometry(5.5, 5.5, 0.8, 20),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x4fc3f7,
                        roughness: 0.1,
                        metalness: 0.8,
                        transparent: true,
                        opacity: 0.7,
                        emissive: 0x2196f3,
                        emissiveIntensity: 0.3
                    })
                );
                water.position.y = 1.7;
                fountain.add(water);
                
                // ì¤‘ì•™ ê¸°ë‘¥ (ë‘¥ê·¼ ëŠë‚Œ)
                const pillar = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.6, 4, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        roughness: 0.3,
                        metalness: 0.7
                    })
                );
                pillar.position.y = 3.5;
                pillar.castShadow = true;
                fountain.add(pillar);
                
                // ìƒë‹¨ êµ¬ì²´ (ë°˜ì§ì´ëŠ”)
                const top = new THREE.Mesh(
                    new THREE.SphereGeometry(1, 20, 20),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x4fc3f7,
                        roughness: 0.2,
                        metalness: 0.8,
                        emissive: 0x2196f3,
                        emissiveIntensity: 0.5
                    })
                );
                top.position.y = 6;
                top.castShadow = true;
                fountain.add(top);
                
                this.scene.add(fountain);
                
                // ê°€ë¡œë“± (í¬ê·¼í•œ ì¡°ëª…)
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = Math.cos(angle) * 28;
                    const z = Math.sin(angle) * 28;
                    this.createWarmLamp(x, 0, z);
                }
            }

            createWarmLamp(x, y, z) {
                const lamp = new THREE.Group();
                
                // ê¸°ë‘¥ (ë‘¥ê·¼ ëŠë‚Œ)
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.3, 7, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff9a76,
                        roughness: 0.5,
                        metalness: 0.4
                    })
                );
                pole.position.y = 3.5;
                pole.castShadow = true;
                lamp.add(pole);
                
                // ì „êµ¬ (ë”°ëœ»í•œ ë¹›)
                const bulb = new THREE.Mesh(
                    new THREE.SphereGeometry(0.9, 16, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        roughness: 0.2,
                        metalness: 0.8,
                        emissive: 0xffa500,
                        emissiveIntensity: 1.2
                    })
                );
                bulb.position.y = 7.5;
                lamp.add(bulb);
                
                // ì‹¤ì œ í¬ì¸íŠ¸ ë¼ì´íŠ¸
                const pointLight = new THREE.PointLight(0xffd700, 0.8, 25);
                pointLight.position.y = 7.5;
                pointLight.castShadow = true;
                pointLight.shadow.mapSize.width = 512;
                pointLight.shadow.mapSize.height = 512;
                lamp.add(pointLight);
                
                lamp.position.set(x, y, z);
                this.scene.add(lamp);
            }

            createPaths() {
                // í¬ê·¼í•œ ëŒê¸¸
                const pathMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xd2b48c,
                    roughness: 0.8,
                    metalness: 0.1
                });
                
                // ê°€ë¡œ ê¸¸
                const pathH = new THREE.Mesh(
                    new THREE.BoxGeometry(this.villageSize, 0.2, 5),
                    pathMaterial
                );
                pathH.position.y = 0.1;
                pathH.receiveShadow = true;
                this.scene.add(pathH);
                
                // ì„¸ë¡œ ê¸¸
                const pathV = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 0.2, this.villageSize),
                    pathMaterial
                );
                pathV.position.y = 0.1;
                pathV.receiveShadow = true;
                this.scene.add(pathV);
            }

            createCozyBuildings() {
                const positions = [
                    { x: -50, z: -70, type: 'round', color: 0xff9aa2 },
                    { x: 0, z: -70, type: 'shop', color: 0xffdac1 },
                    { x: 50, z: -70, type: 'round', color: 0xffee93 },
                    { x: 70, z: -40, type: 'tower', color: 0xb5ead7 },
                    { x: 70, z: 40, type: 'round', color: 0xc7ceea },
                    { x: -50, z: 70, type: 'shop', color: 0xffc8dd },
                    { x: 0, z: 70, type: 'round', color: 0xbde0fe },
                    { x: 50, z: 70, type: 'shop', color: 0xf1c0e8 },
                    { x: -70, z: -40, type: 'tower', color: 0xffc6ff },
                    { x: -70, z: 40, type: 'round', color: 0xffffd2 }
                ];
                
                positions.forEach(pos => {
                    if (pos.type === 'round') {
                        this.createRoundHouse(pos.x, 0, pos.z, pos.color);
                    } else if (pos.type === 'shop') {
                        this.createCozyShop(pos.x, 0, pos.z, pos.color);
                    } else if (pos.type === 'tower') {
                        this.createCozyTower(pos.x, 0, pos.z, pos.color);
                    }
                });
            }

            createRoundHouse(x, y, z, color) {
                const house = new THREE.Group();
                
                // âœ¨ ë‘¥ê·¼ ë²½ (ëª½ê¸€ëª½ê¸€)
                const wall = new THREE.Mesh(
                    new THREE.CylinderGeometry(5.5, 5.5, 7, 20),
                    new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.7,
                        metalness: 0.2
                    })
                );
                wall.position.y = 3.5;
                wall.castShadow = true;
                wall.receiveShadow = true;
                house.add(wall);
                
                // âœ¨ ê·€ì—¬ìš´ ì§€ë¶• (ë¶€ë“œëŸ¬ìš´ ì›ë¿”)
                const roof = new THREE.Mesh(
                    new THREE.ConeGeometry(7.5, 5, 20),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6b6b,
                        roughness: 0.6,
                        metalness: 0.3
                    })
                );
                roof.position.y = 9.5;
                roof.castShadow = true;
                house.add(roof);
                
                // ì°½ë¬¸ë“¤ (ë°˜ì§ì´ëŠ”)
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const window = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 0.3),
                        new THREE.MeshStandardMaterial({ 
                            color: 0x87ceeb,
                            roughness: 0.1,
                            metalness: 0.9,
                            emissive: 0x4fc3f7,
                            emissiveIntensity: 0.4
                        })
                    );
                    window.position.set(
                        Math.cos(angle) * 5.6,
                        5,
                        Math.sin(angle) * 5.6
                    );
                    window.rotation.y = -angle;
                    house.add(window);
                }
                
                // ë¬¸ (ë‘¥ê·¼ ëŠë‚Œ)
                const door = new THREE.Mesh(
                    new THREE.BoxGeometry(2.5, 4, 0.4),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8b4513,
                        roughness: 0.8,
                        metalness: 0.1
                    })
                );
                door.position.set(0, 2, 5.6);
                house.add(door);
                
                house.position.set(x, y, z);
                this.scene.add(house);
                this.buildings.push(house);
            }

            createCozyShop(x, y, z, color) {
                const shop = new THREE.Group();
                
                // âœ¨ ë³¸ì²´ (ë‘¥ê·¼ ëª¨ì„œë¦¬ ëŠë‚Œ)
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(13, 8, 11),
                    new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.6,
                        metalness: 0.2
                    })
                );
                body.position.y = 4;
                body.castShadow = true;
                body.receiveShadow = true;
                shop.add(body);
                
                // ì§€ë¶•
                const roof = new THREE.Mesh(
                    new THREE.BoxGeometry(14, 1.5, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8b4513,
                        roughness: 0.7,
                        metalness: 0.2
                    })
                );
                roof.position.y = 8.75;
                roof.castShadow = true;
                shop.add(roof);
                
                // âœ¨ í™”ë ¤í•œ ê°„íŒ (ë°œê´‘)
                const sign = new THREE.Mesh(
                    new THREE.BoxGeometry(9, 2.5, 0.6),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff1493,
                        roughness: 0.3,
                        metalness: 0.7,
                        emissive: 0xff1493,
                        emissiveIntensity: 0.8
                    })
                );
                sign.position.set(0, 10, 0);
                shop.add(sign);
                
                // í° ìœ ë¦¬ì°½ (ë°˜ì§ì´ëŠ”)
                const window = new THREE.Mesh(
                    new THREE.BoxGeometry(10, 5.5, 0.4),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x87ceeb,
                        roughness: 0.1,
                        metalness: 0.9,
                        transparent: true,
                        opacity: 0.6,
                        emissive: 0x4fc3f7,
                        emissiveIntensity: 0.3
                    })
                );
                window.position.set(0, 4, 5.6);
                shop.add(window);
                
                shop.position.set(x, y, z);
                this.scene.add(shop);
                this.buildings.push(shop);
            }

            createCozyTower(x, y, z, color) {
                const tower = new THREE.Group();
                
                // 3ë‹¨ íƒ€ì›Œ (ë‘¥ê·¼ ëŠë‚Œ)
                for (let i = 0; i < 3; i++) {
                    const segment = new THREE.Mesh(
                        new THREE.CylinderGeometry(4.5 - i * 0.6, 5 - i * 0.6, 6, 16),
                        new THREE.MeshStandardMaterial({ 
                            color: i % 2 === 0 ? color : 0xffffff,
                            roughness: 0.6,
                            metalness: 0.3
                        })
                    );
                    segment.position.y = 3 + i * 6;
                    segment.castShadow = true;
                    segment.receiveShadow = true;
                    tower.add(segment);
                }
                
                // ì§€ë¶• (ë°˜ì§ì´ëŠ”)
                const top = new THREE.Mesh(
                    new THREE.ConeGeometry(5, 6, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        roughness: 0.3,
                        metalness: 0.8,
                        emissive: 0xff8c00,
                        emissiveIntensity: 0.4
                    })
                );
                top.position.y = 24;
                top.castShadow = true;
                tower.add(top);
                
                // ê¹ƒë°œ
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 4, 8),
                    new THREE.MeshStandardMaterial({ color: 0x8b4513 })
                );
                pole.position.y = 29;
                tower.add(pole);
                
                const flag = new THREE.Mesh(
                    new THREE.PlaneGeometry(2.5, 1.8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6b9d,
                        side: THREE.DoubleSide,
                        emissive: 0xff1493,
                        emissiveIntensity: 0.3
                    })
                );
                flag.position.set(1.2, 29, 0);
                tower.add(flag);
                
                tower.position.set(x, y, z);
                this.scene.add(tower);
                this.buildings.push(tower);
            }

            createCozyNature() {
                const excludeRadius = 50;
                
                // í™”ë ¤í•œ ë‚˜ë¬´ë“¤
                for (let i = 0; i < 80; i++) {
                    const x = (Math.random() - 0.5) * 180;
                    const z = (Math.random() - 0.5) * 180;
                    
                    if (Math.abs(x) > excludeRadius || Math.abs(z) > excludeRadius) {
                        const treeType = Math.floor(Math.random() * 2);
                        if (treeType === 0) {
                            this.createSoftTree(x, 0, z, 0xff9aa2);
                        } else {
                            this.createSoftTree(x, 0, z, 0xb5ead7);
                        }
                    }
                }
                
                // ë°˜ì§ì´ëŠ” ê½ƒë“¤
                for (let i = 0; i < 60; i++) {
                    const x = (Math.random() - 0.5) * 70;
                    const z = (Math.random() - 0.5) * 70;
                    if (Math.abs(x) < 45 && Math.abs(z) < 45) {
                        this.createSparkleFlower(x, 0, z);
                    }
                }
            }

            createSoftTree(x, y, z, leafColor) {
                const tree = new THREE.Group();
                
                // ì¤„ê¸°
                const trunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.5, 4, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8b4513,
                        roughness: 0.9,
                        metalness: 0.1
                    })
                );
                trunk.position.y = 2;
                trunk.castShadow = true;
                tree.add(trunk);
                
                // âœ¨ ëª½ê¸€ëª½ê¸€í•œ ì
                const leaves = new THREE.Mesh(
                    new THREE.SphereGeometry(2.5, 12, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: leafColor,
                        roughness: 0.7,
                        metalness: 0.2,
                        emissive: leafColor,
                        emissiveIntensity: 0.2
                    })
                );
                leaves.position.y = 5.5;
                leaves.castShadow = true;
                tree.add(leaves);
                
                tree.position.set(x, y, z);
                this.scene.add(tree);
            }

            createSparkleFlower(x, y, z) {
                const colors = [
                    0xff9aa2, 0xffdac1, 0xffee93, 
                    0xb5ead7, 0xc7ceea, 0xffc8dd
                ];
                const color = colors[Math.floor(Math.random() * colors.length)];
                
                // ì¤„ê¸°
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 1.2, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x4a7c59,
                        roughness: 0.8
                    })
                );
                stem.position.set(x, 0.6, z);
                stem.castShadow = true;
                this.scene.add(stem);
                
                // âœ¨ ë°˜ì§ì´ëŠ” ê½ƒì
                const petal = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 12, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.4,
                        metalness: 0.6,
                        emissive: color,
                        emissiveIntensity: 0.4
                    })
                );
                petal.position.set(x, 1.3, z);
                petal.castShadow = true;
                this.scene.add(petal);
            }

            createDecorations() {
                // ë²¤ì¹˜ë“¤ (ê·€ì—¬ìš´ ìƒ‰ìƒ)
                const benchPos = [
                    {x: -18, z: -18}, {x: 18, z: -18},
                    {x: -18, z: 18}, {x: 18, z: 18}
                ];
                benchPos.forEach(p => this.createCuteBench(p.x, 0, p.z));
                
                // í‘œì§€íŒë“¤
                this.createCuteSign(-35, 0, 0);
                this.createCuteSign(35, 0, 0);
                this.createCuteSign(0, 0, -35);
                this.createCuteSign(0, 0, 35);
            }

            createCuteBench(x, y, z) {
                const bench = new THREE.Group();
                
                // âœ¨ ë‘¥ê·¼ ë²¤ì¹˜
                const seat = new THREE.Mesh(
                    new THREE.BoxGeometry(3.5, 0.5, 1.2),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff9aa2,
                        roughness: 0.6,
                        metalness: 0.3
                    })
                );
                seat.position.y = 1.2;
                seat.castShadow = true;
                bench.add(seat);
                
                const back = new THREE.Mesh(
                    new THREE.BoxGeometry(3.5, 1.5, 0.4),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffb3ba,
                        roughness: 0.6,
                        metalness: 0.3
                    })
                );
                back.position.set(0, 2, -0.4);
                back.castShadow = true;
                bench.add(back);
                
                bench.position.set(x, y, z);
                this.scene.add(bench);
            }

            createCuteSign(x, y, z) {
                const sign = new THREE.Group();
                
                const pole = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.2, 4, 12),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x8b4513,
                        roughness: 0.8
                    })
                );
                pole.position.y = 2;
                pole.castShadow = true;
                sign.add(pole);
                
                // âœ¨ ë°˜ì§ì´ëŠ” í‘œì§€íŒ
                const board = new THREE.Mesh(
                    new THREE.BoxGeometry(5, 2, 0.4),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xffd700,
                        roughness: 0.3,
                        metalness: 0.7,
                        emissive: 0xff8c00,
                        emissiveIntensity: 0.3
                    })
                );
                board.position.y = 4.5;
                board.castShadow = true;
                sign.add(board);
                
                sign.position.set(x, y, z);
                this.scene.add(sign);
            }

            createPlayer() {
                this.player = new THREE.Group();
                this.player.userData.animationPhase = 0; // ì• ë‹ˆë©”ì´ì…˜ìš©
                this.createCharacter(this.currentCharacter);
                this.player.position.set(0, 1, 0);
                this.scene.add(this.player);
            }

            // ğŸ”« ê±°ëŒ€í•œ ì¥ë‚œê° ì´ ìƒì„± (ë¡œì»¬ ì¢Œí‘œê³„ ì •ë ¬!)
            createWeapon() {
                this.weapon = new THREE.Group();
                
                // ğŸ”´ ì´ì‹  (Barrel) - Zì¶• ì •ë©´ ë°©í–¥ìœ¼ë¡œ!
                const barrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 1.2, 16),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xFF0000, // ì§„í•œ ë¹¨ê°„ìƒ‰
                        wireframe: false
                    })
                );
                // CylinderGeometryëŠ” Yì¶•ì„ í–¥í•˜ë¯€ë¡œ, Xì¶• ê¸°ì¤€ 90ë„ íšŒì „í•˜ì—¬ Zì¶•(ì •ë©´)ì„ í–¥í•˜ê²Œ!
                barrel.rotation.x = Math.PI / 2;
                barrel.position.z = 0.6; // Zì¶• ì•ìª½ (ì •ë©´)
                barrel.castShadow = true;
                this.weapon.add(barrel);
                
                // ğŸ”µ ì†ì¡ì´ (Grip) - ë’¤ìª½ ì•„ë˜
                const grip = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.5, 0.25),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x0000FF, // ì§„í•œ íŒŒë€ìƒ‰
                        wireframe: false
                    })
                );
                grip.position.set(0, -0.3, -0.1); // ë’¤ìª½ ì•„ë˜
                grip.castShadow = true;
                this.weapon.add(grip);
                
                // ğŸŸ¡ ë°©ì•„ì‡  (Trigger) - ì†ì¡ì´ ì•
                const trigger = new THREE.Mesh(
                    new THREE.BoxGeometry(0.08, 0.15, 0.1),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xFFFF00, // ë…¸ë€ìƒ‰
                        wireframe: false
                    })
                );
                trigger.position.set(0, -0.1, 0); // ì¤‘ì•™
                trigger.castShadow = true;
                this.weapon.add(trigger);
                
                // ğŸŸ  ì´êµ¬ ì¥ì‹ (Muzzle) - ì•ìª½ ë
                const muzzle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.2, 0.15, 0.2, 16),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xFF8800, // ì˜¤ë Œì§€ìƒ‰
                        wireframe: false
                    })
                );
                muzzle.rotation.x = Math.PI / 2; // Zì¶• ì •ë©´ ë°©í–¥
                muzzle.position.z = 1.2; // ì´êµ¬ ìœ„ì¹˜ (ì•ìª½)
                muzzle.castShadow = true;
                this.weapon.add(muzzle);
                
                // ğŸŸ£ ì¡°ì¤€ê²½ (Sight) - ì¤‘ì•™ ìœ„
                const sight = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.3, 0.15),
                    new THREE.MeshBasicMaterial({ 
                        color: 0xFF00FF, // ë³´ë¼ìƒ‰
                        wireframe: false
                    })
                );
                sight.position.set(0, 0.3, 0.3); // ì¤‘ì•™ ìœ„
                sight.castShadow = true;
                this.weapon.add(sight);
                
                // â­ ì´êµ¬ ë°©í–¥ ë§ˆì»¤ (ì´ˆë¡ìƒ‰ - ì´êµ¬ê°€ ì–´ë””ë¥¼ í–¥í•˜ëŠ”ì§€ í™•ì¸!)
                this.muzzleFlash = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x00FF00, // ì´ˆë¡ìƒ‰
                        wireframe: false
                    })
                );
                this.muzzleFlash.position.z = 1.4; // ì´êµ¬ ì•ìª½ (Zì¶• = ì •ë©´)
                this.weapon.add(this.muzzleFlash);
                
                // ğŸ¯ ë¬´ê¸°ë¥¼ ìºë¦­í„° ì˜¤ë¥¸ìª½ ì–´ê¹¨ ì•ì— ë¶€ì°© (ë¡œì»¬ ì¢Œí‘œê³„)
                // X = ì˜¤ë¥¸ìª½, Y = ìœ„, Z = ì•
                this.weapon.position.set(0.6, 0.8, 0.5); // ì˜¤ë¥¸ìª½ ì–´ê¹¨ ì•
                this.weapon.rotation.set(0, 0, 0); // íšŒì „ ì—†ìŒ (ìºë¦­í„°ì™€ ê°™ì€ ë°©í–¥)
                this.weapon.scale.set(1.5, 1.5, 1.5); // 1.5ë°° í™•ëŒ€
                this.weapon.visible = false; // ê¸°ë³¸ì ìœ¼ë¡œ ìˆ¨ê¹€
                
                // âœ… ìºë¦­í„° ê·¸ë£¹ì— ë¶€ì°© (ì¤‘ìš”!)
                this.player.add(this.weapon);
                
                // ğŸ ë””ë²„ê¹… ë¡œê·¸
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('ğŸ”« ì´ ìƒì„± ì™„ë£Œ! (ë¡œì»¬ ì¢Œí‘œê³„ ì •ë ¬)');
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('âœ… ì´ ìœ„ì¹˜ (ë¡œì»¬):', this.weapon.position);
                console.log('âœ… ì´ íšŒì „ (ë¡œì»¬):', this.weapon.rotation);
                console.log('âœ… ì´êµ¬ ë°©í–¥: Zì¶• ì •ë©´ (ìºë¦­í„° ì •ë©´ê³¼ ì¼ì¹˜)');
                console.log('âœ… ì´ˆë¡ìƒ‰ ë§ˆì»¤: ì´êµ¬ ë (Z = +1.4)');
                console.log('âœ… ë¶€ëª¨: player (ìºë¦­í„° ê·¸ë£¹)');
                console.log('ğŸ’¡ ìºë¦­í„°ê°€ íšŒì „í•˜ë©´ ì´ë„ ê°™ì´ íšŒì „í•©ë‹ˆë‹¤!');
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            }

            // ğŸ”Š Web Audio API ì´ˆê¸°í™” (íš¨ê³¼ìŒ)
            setupAudio() {
                try {
                    // AudioContext ìƒì„± (ì‚¬ìš©ì ì œìŠ¤ì²˜ í›„ í™œì„±í™”)
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('ğŸ”Š ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!');
                } catch (error) {
                    console.warn('âš ï¸ ì˜¤ë””ì˜¤ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
                }
            }

            // ğŸ”Š ë°œì‚¬ íš¨ê³¼ìŒ (8ë¹„íŠ¸ ë ˆíŠ¸ë¡œ ìŠ¤íƒ€ì¼!)
            playShootSound() {
                if (!this.audioContext) return;
                
                try {
                    // Resume AudioContext (ë¸Œë¼ìš°ì € ì •ì±…)
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    // Oscillator ìƒì„± (ì‚¬ì¸íŒŒ)
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // 8ë¹„íŠ¸ ë ˆíŠ¸ë¡œ "í”¼ìŠ~" ì‚¬ìš´ë“œ
                    oscillator.type = 'square'; // ì‚¬ê°íŒŒ (8ë¹„íŠ¸ ëŠë‚Œ)
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime); // ë†’ì€ ìŒ
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1); // ë‚®ì•„ì§
                    
                    // ë³¼ë¥¨ ì—”ë²¨ë¡œí”„ (ë¹ ë¥´ê²Œ ì¤„ì–´ë“¦)
                    gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);
                    
                    // ì¬ìƒ
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                    
                } catch (error) {
                    console.warn('âš ï¸ ì‚¬ìš´ë“œ ì¬ìƒ ì‹¤íŒ¨:', error);
                }
            }

            // ğŸ‘¾ ìŠ¬ë¼ì„ ëª¬ìŠ¤í„° ì†Œí™˜
            spawnMonsters() {
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('ğŸ‘¾ ìŠ¬ë¼ì„ ëª¬ìŠ¤í„° ì†Œí™˜ ì¤‘...');
                
                const spawnRadius = this.villageSize / 2 - 10; // ë§ˆì„ ê°€ì¥ìë¦¬
                
                for (let i = 0; i < this.monsterCount; i++) {
                    // ëœë¤ ìœ„ì¹˜
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * spawnRadius;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const slime = this.createSlime(x, z);
                    this.monsters.push(slime);
                    this.scene.add(slime);
                }
                
                console.log(`âœ… ìŠ¬ë¼ì„ ${this.monsterCount}ë§ˆë¦¬ ì†Œí™˜ ì™„ë£Œ!`);
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
            }

            // ğŸ‘¾ ì‘ê³  ê·€ì—¬ìš´ ëª¬ìŠ¤í„° ìƒì„± (ë©”ì´í”Œ ìŠ¤íƒ€ì¼!)
            createSlime(x, z) {
                // ëœë¤ìœ¼ë¡œ ìŠ¬ë¼ì„ ë˜ëŠ” ë²„ì„¯ ìƒì„±
                const type = Math.random() > 0.5 ? 'slime' : 'mushroom';
                
                if (type === 'slime') {
                    return this.createTinySlime(x, z);
                } else {
                    return this.createTinyMushroom(x, z);
                }
            }

            // ğŸŸ¢ ì‘ì€ ìŠ¬ë¼ì„ (ë©”ì´í”ŒìŠ¤í† ë¦¬ ìŠ¤íƒ€ì¼)
            createTinySlime(x, z) {
                const slime = new THREE.Group();
                
                const radius = 0.35; // ì‘ì€ í¬ê¸°!
                
                // ëª¸í†µ (ì‘ê³  ë°˜íˆ¬ëª…í•œ ë¼ì„ìƒ‰)
                const body = new THREE.Mesh(
                    new THREE.SphereGeometry(radius, 16, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0x32CD32, // ë¼ì„ìƒ‰
                        transparent: true,
                        opacity: 0.8,
                        wireframe: false
                    })
                );
                body.scale.set(1, 0.7, 1); // Yì¶• ì•½ê°„ ë‚©ì‘ (ìŠ¬ë¼ì„ ëŠë‚Œ)
                body.position.y = radius * 0.7; // ë°”ë‹¥ì—ì„œ ì¤‘ì‹¬ê¹Œì§€
                body.castShadow = true;
                slime.add(body);
                
                // ì™¼ìª½ ëˆˆ (ì‘ì€ ê²€ì€ ì )
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                leftEye.position.set(-0.12, radius * 0.8, radius * 0.9);
                slime.add(leftEye);
                
                // ì˜¤ë¥¸ìª½ ëˆˆ
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                rightEye.position.set(0.12, radius * 0.8, radius * 0.9);
                slime.add(rightEye);
                
                // ì… (ì‘ì€ ë¯¸ì†Œ)
                const mouth = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                mouth.position.set(0, radius * 0.6, radius * 0.95);
                slime.add(mouth);
                
                // ğŸ“ ìœ„ì¹˜ ì„¤ì • (ë°”ë‹¥ì— ì •í™•íˆ ë¶™ì´ê¸°)
                slime.position.set(x, 0, z);
                
                // ìŠ¬ë¼ì„ ë°ì´í„°
                slime.userData = {
                    type: 'slime',
                    health: 1,
                    radius: radius, // ì¶©ëŒ íŒì • ë°˜ê²½ (ì‘ì•„ì§!)
                    speed: 0.02 // ëŠë¦° ì†ë„
                };
                
                return slime;
            }

            // ğŸ„ ì‘ì€ ì£¼í™©ë²„ì„¯ (ë©”ì´í”ŒìŠ¤í† ë¦¬ ìŠ¤íƒ€ì¼)
            createTinyMushroom(x, z) {
                const mushroom = new THREE.Group();
                
                // ê°“ (ì£¼í™©ìƒ‰ ë°˜êµ¬)
                const capRadius = 0.4;
                const cap = new THREE.Mesh(
                    new THREE.SphereGeometry(capRadius, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                    new THREE.MeshBasicMaterial({
                        color: 0xFFA500, // ì£¼í™©ìƒ‰
                        wireframe: false
                    })
                );
                cap.position.y = 0.4; // ê°“ ë†’ì´
                cap.castShadow = true;
                mushroom.add(cap);
                
                // ê°“ ë¬´ëŠ¬ (í°ìƒ‰ ì )
                const spot1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                );
                spot1.position.set(0.15, 0.5, 0.15);
                mushroom.add(spot1);
                
                const spot2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.06, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
                );
                spot2.position.set(-0.12, 0.48, 0.12);
                mushroom.add(spot2);
                
                // ì¤„ê¸° (í¬ë¦¼ìƒ‰ ì›ê¸°ë‘¥)
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.15, 0.15, 0.4, 12),
                    new THREE.MeshBasicMaterial({
                        color: 0xFFFACD, // í¬ë¦¼ìƒ‰
                        wireframe: false
                    })
                );
                stem.position.y = 0.2; // ì¤„ê¸° ì¤‘ì‹¬
                stem.castShadow = true;
                mushroom.add(stem);
                
                // ì™¼ìª½ ëˆˆ
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                leftEye.position.set(-0.08, 0.25, 0.14);
                mushroom.add(leftEye);
                
                // ì˜¤ë¥¸ìª½ ëˆˆ
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                rightEye.position.set(0.08, 0.25, 0.14);
                mushroom.add(rightEye);
                
                // ì… (ì‘ì€ ë¯¸ì†Œ)
                const mouth = new THREE.Mesh(
                    new THREE.SphereGeometry(0.03, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                mouth.position.set(0, 0.15, 0.16);
                mushroom.add(mouth);
                
                // ğŸ“ ìœ„ì¹˜ ì„¤ì • (ë°”ë‹¥ì— ì •í™•íˆ ë¶™ì´ê¸°)
                mushroom.position.set(x, 0, z);
                
                // ë²„ì„¯ ë°ì´í„°
                mushroom.userData = {
                    type: 'mushroom',
                    health: 1,
                    radius: 0.4, // ì¶©ëŒ íŒì • ë°˜ê²½
                    speed: 0.02 // ëŠë¦° ì†ë„
                };
                
                return mushroom;
            }

            createCharacter(type) {
                // ë¬´ê¸°ë¥¼ ì œì™¸í•œ ìºë¦­í„°ë§Œ ì œê±°
                const childrenToRemove = [];
                for (let i = 0; i < this.player.children.length; i++) {
                    if (this.player.children[i] !== this.weapon) {
                        childrenToRemove.push(this.player.children[i]);
                    }
                }
                childrenToRemove.forEach(child => this.player.remove(child));

                if (type === 'ryan') {
                    this.createRyan();
                } else if (type === 'muzi') {
                    this.createMuzi();
                } else if (type === 'apeach') {
                    this.createApeach();
                }
            }

            // ğŸ¦ ë¼ì´ì–¸ - ê°ˆê¸° ì—†ëŠ” ìˆ˜ì‚¬ì
            createRyan() {
                const ryan = new THREE.Group();
                ryan.name = 'ryan';
                
                // === HEAD ===
                const head = new THREE.Group();
                head.name = 'head';
                
                // ì–¼êµ´ (í° êµ¬ì²´)
                const face = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 32, 32),
                    new THREE.MeshToonMaterial({ 
                        color: 0xDAA520, // í™©ê¸ˆìƒ‰
                        roughness: 0.7,
                        metalness: 0.0
                    })
                );
                face.castShadow = true;
                face.receiveShadow = true;
                head.add(face);
                
                // ì£¼ë‘¥ì´ (ì‚´êµ¬ìƒ‰)
                const muzzle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.45, 24, 24),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFE4B5,
                        roughness: 0.7,
                        metalness: 0.0
                    })
                );
                muzzle.scale.set(0.9, 0.7, 1);
                muzzle.position.set(0, -0.1, 0.6);
                muzzle.castShadow = true;
                muzzle.receiveShadow = true;
                head.add(muzzle);
                
                // ê·€ (ë‘¥ê·¼ ì‘ì€ ë°˜êµ¬)
                const earGeometry = new THREE.SphereGeometry(0.25, 20, 20, 0, Math.PI * 2, 0, Math.PI / 2);
                const earMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xDAA520,
                    roughness: 0.7,
                    metalness: 0.0
                });
                
                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(-0.5, 0.6, 0.2);
                leftEar.rotation.z = -0.3;
                leftEar.castShadow = true;
                head.add(leftEar);
                
                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(0.5, 0.6, 0.2);
                rightEar.rotation.z = 0.3;
                rightEar.castShadow = true;
                head.add(rightEar);
                
                // ê·€ ì•ˆìª½ (ë¶„í™ìƒ‰)
                const innerEarMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xffb6c1,
                    roughness: 0.6
                });
                
                const leftInnerEar = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    innerEarMaterial
                );
                leftInnerEar.position.set(-0.5, 0.55, 0.3);
                leftInnerEar.scale.set(0.8, 0.6, 0.5);
                head.add(leftInnerEar);
                
                const rightInnerEar = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    innerEarMaterial
                );
                rightInnerEar.position.set(0.5, 0.55, 0.3);
                rightInnerEar.scale.set(0.8, 0.6, 0.5);
                head.add(rightInnerEar);
                
                // ëˆˆ (ì‘ê³  ë¬´í‘œì •)
                const eyeMaterial = new THREE.MeshToonMaterial({ 
                    color: 0x000000,
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 16, 16),
                    eyeMaterial
                );
                leftEye.position.set(-0.25, 0.15, 0.7);
                head.add(leftEye);
                
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 16, 16),
                    eyeMaterial
                );
                rightEye.position.set(0.25, 0.15, 0.7);
                head.add(rightEye);
                
                // ì½” (ê²€ì€ ì‹¤ë¦°ë”)
                const nose = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.12, 0.12, 0.15, 16),
                    new THREE.MeshToonMaterial({ 
                        color: 0x000000,
                        roughness: 0.5
                    })
                );
                nose.rotation.x = Math.PI / 2;
                nose.position.set(0, 0, 0.9);
                nose.castShadow = true;
                head.add(nose);
                
                // ì… (ê°„ë‹¨í•œ ì„ )
                const mouthShape = new THREE.Shape();
                mouthShape.moveTo(-0.15, 0);
                mouthShape.quadraticCurveTo(0, -0.1, 0.15, 0);
                
                const mouthGeometry = new THREE.ShapeGeometry(mouthShape);
                const mouth = new THREE.Mesh(
                    mouthGeometry,
                    new THREE.MeshToonMaterial({ 
                        color: 0x000000,
                        side: THREE.DoubleSide
                    })
                );
                mouth.position.set(0, -0.25, 0.85);
                head.add(mouth);
                
                head.position.y = 1;
                ryan.add(head);
                
                // === BODY ===
                const body = new THREE.Group();
                body.name = 'body';
                
                const bodyMesh = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.5, 0.8, 20, 32),
                    new THREE.MeshToonMaterial({ 
                        color: 0xDAA520,
                        roughness: 0.7,
                        metalness: 0.0
                    })
                );
                bodyMesh.castShadow = true;
                bodyMesh.receiveShadow = true;
                body.add(bodyMesh);
                
                // ë°° (ì‚´êµ¬ìƒ‰)
                const belly = new THREE.Mesh(
                    new THREE.SphereGeometry(0.4, 24, 24),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFE4B5,
                        roughness: 0.7
                    })
                );
                belly.scale.set(0.9, 1, 0.7);
                belly.position.set(0, 0, 0.35);
                belly.castShadow = true;
                body.add(belly);
                
                body.position.y = 0;
                ryan.add(body);
                
                // === ARMS ===
                const arms = new THREE.Group();
                arms.name = 'arms';
                
                const armMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xDAA520,
                    roughness: 0.7
                });
                
                const leftArm = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.6, 12, 16),
                    armMaterial
                );
                leftArm.position.set(-0.55, 0.2, 0);
                leftArm.rotation.z = 0.3;
                leftArm.castShadow = true;
                leftArm.name = 'leftArm';
                arms.add(leftArm);
                
                const rightArm = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.6, 12, 16),
                    armMaterial
                );
                rightArm.position.set(0.55, 0.2, 0);
                rightArm.rotation.z = -0.3;
                rightArm.castShadow = true;
                rightArm.name = 'rightArm';
                arms.add(rightArm);
                
                ryan.add(arms);
                
                // === LEGS ===
                const legs = new THREE.Group();
                legs.name = 'legs';
                
                const legMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xDAA520,
                    roughness: 0.7
                });
                
                const leftLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.18, 0.5, 12, 16),
                    legMaterial
                );
                leftLeg.position.set(-0.25, -0.7, 0);
                leftLeg.castShadow = true;
                leftLeg.name = 'leftLeg';
                legs.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.18, 0.5, 12, 16),
                    legMaterial
                );
                rightLeg.position.set(0.25, -0.7, 0);
                rightLeg.castShadow = true;
                rightLeg.name = 'rightLeg';
                legs.add(rightLeg);
                
                ryan.add(legs);
                
                // === TAIL ===
                const tail = new THREE.Group();
                tail.name = 'tail';
                
                const tailBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 0.4, 12),
                    armMaterial
                );
                tailBase.position.set(0, -0.2, -0.4);
                tailBase.rotation.x = -0.5;
                tailBase.castShadow = true;
                tail.add(tailBase);
                
                const tailTip = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    armMaterial
                );
                tailTip.position.set(0, -0.3, -0.6);
                tailTip.castShadow = true;
                tail.add(tailTip);
                
                ryan.add(tail);
                
                this.player.add(ryan);
                this.player.userData.character = ryan;
            }

            // ğŸ° ë¬´ì§€ & ì½˜
            createMuzi() {
                const muzi = new THREE.Group();
                muzi.name = 'muzi';
                
                // === BODY (ë…¸ë€ ë‹¨ë¬´ì§€) ===
                const body = new THREE.Group();
                body.name = 'body';
                
                const bodyMesh = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.45, 1, 20, 32),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFFF00, // ë…¸ë€ìƒ‰
                        roughness: 0.7,
                        metalness: 0.0
                    })
                );
                bodyMesh.castShadow = true;
                bodyMesh.receiveShadow = true;
                body.add(bodyMesh);
                
                body.position.y = 0.3;
                muzi.add(body);
                
                // === HEAD (í°ìƒ‰ í† ë¼ ì˜·) ===
                const head = new THREE.Group();
                head.name = 'head';
                
                // ì–¼êµ´
                const face = new THREE.Mesh(
                    new THREE.SphereGeometry(0.6, 32, 32),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFFFFF, // í°ìƒ‰
                        roughness: 0.7
                    })
                );
                face.castShadow = true;
                face.receiveShadow = true;
                head.add(face);
                
                // í† ë¼ ê·€ (ê¸¸ì­‰í•œ ìº¡ìŠ)
                const earMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xFFFFFF,
                    roughness: 0.7
                });
                
                const leftEar = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.8, 12, 16),
                    earMaterial
                );
                leftEar.position.set(-0.3, 0.8, 0);
                leftEar.rotation.z = -0.2;
                leftEar.castShadow = true;
                head.add(leftEar);
                
                const rightEar = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.8, 12, 16),
                    earMaterial
                );
                rightEar.position.set(0.3, 0.8, 0);
                rightEar.rotation.z = 0.2;
                rightEar.castShadow = true;
                head.add(rightEar);
                
                // ê·€ ì•ˆìª½ (í•‘í¬)
                const innerEarMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xffb6c1,
                    roughness: 0.6
                });
                
                const leftInnerEar = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.08, 0.5, 8, 12),
                    innerEarMaterial
                );
                leftInnerEar.position.set(-0.3, 0.8, 0.05);
                leftInnerEar.rotation.z = -0.2;
                head.add(leftInnerEar);
                
                const rightInnerEar = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.08, 0.5, 8, 12),
                    innerEarMaterial
                );
                rightInnerEar.position.set(0.3, 0.8, 0.05);
                rightInnerEar.rotation.z = 0.2;
                head.add(rightInnerEar);
                
                // ëˆˆ
                const eyeMaterial = new THREE.MeshToonMaterial({ 
                    color: 0x000000,
                    roughness: 0.3
                });
                
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    eyeMaterial
                );
                leftEye.position.set(-0.2, 0.1, 0.55);
                head.add(leftEye);
                
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    eyeMaterial
                );
                rightEye.position.set(0.2, 0.1, 0.55);
                head.add(rightEye);
                
                // ë¹¨ê°„ ë³¼ í„°ì¹˜
                const cheekMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xff6b6b,
                    roughness: 0.5,
                    emissive: 0xff6b6b,
                    emissiveIntensity: 0.2
                });
                
                const leftCheek = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 16, 16),
                    cheekMaterial
                );
                leftCheek.position.set(-0.35, -0.05, 0.5);
                leftCheek.scale.set(1, 0.8, 0.5);
                head.add(leftCheek);
                
                const rightCheek = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 16, 16),
                    cheekMaterial
                );
                rightCheek.position.set(0.35, -0.05, 0.5);
                rightCheek.scale.set(1, 0.8, 0.5);
                head.add(rightCheek);
                
                // ì… (ì›ƒëŠ” í‘œì •)
                const mouthShape = new THREE.Shape();
                mouthShape.moveTo(-0.1, 0);
                mouthShape.quadraticCurveTo(0, -0.08, 0.1, 0);
                
                const mouth = new THREE.Mesh(
                    new THREE.ShapeGeometry(mouthShape),
                    new THREE.MeshToonMaterial({ 
                        color: 0x000000,
                        side: THREE.DoubleSide
                    })
                );
                mouth.position.set(0, -0.15, 0.58);
                head.add(mouth);
                
                head.position.y = 1.1;
                muzi.add(head);
                
                // === ARMS ===
                const arms = new THREE.Group();
                arms.name = 'arms';
                
                const armMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xFFFF00,
                    roughness: 0.7
                });
                
                const leftArm = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.12, 0.5, 12, 16),
                    armMaterial
                );
                leftArm.position.set(-0.5, 0.5, 0);
                leftArm.rotation.z = 0.4;
                leftArm.castShadow = true;
                leftArm.name = 'leftArm';
                arms.add(leftArm);
                
                const rightArm = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.12, 0.5, 12, 16),
                    armMaterial
                );
                rightArm.position.set(0.5, 0.5, 0);
                rightArm.rotation.z = -0.4;
                rightArm.castShadow = true;
                rightArm.name = 'rightArm';
                arms.add(rightArm);
                
                muzi.add(arms);
                
                // === LEGS ===
                const legs = new THREE.Group();
                legs.name = 'legs';
                
                const leftLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.4, 12, 16),
                    armMaterial
                );
                leftLeg.position.set(-0.2, -0.5, 0);
                leftLeg.castShadow = true;
                leftLeg.name = 'leftLeg';
                legs.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.4, 12, 16),
                    armMaterial
                );
                rightLeg.position.set(0.2, -0.5, 0);
                rightLeg.castShadow = true;
                rightLeg.name = 'rightLeg';
                legs.add(rightLeg);
                
                muzi.add(legs);
                
                // === ğŸŠ CON (ì‘ì€ ì•…ì–´) ===
                const con = new THREE.Group();
                con.name = 'con';
                
                // ì½˜ ëª¸í†µ
                const conBody = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.15, 0.3, 12, 16),
                    new THREE.MeshToonMaterial({ 
                        color: 0x00FF00, // ì´ˆë¡ìƒ‰
                        roughness: 0.7
                    })
                );
                conBody.rotation.z = Math.PI / 2;
                conBody.castShadow = true;
                con.add(conBody);
                
                // ì½˜ ë¨¸ë¦¬
                const conHead = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 16, 16),
                    new THREE.MeshToonMaterial({ 
                        color: 0x00FF00,
                        roughness: 0.7
                    })
                );
                conHead.position.set(0.25, 0, 0);
                conHead.scale.set(1.2, 0.8, 0.9);
                conHead.castShadow = true;
                con.add(conHead);
                
                // ì½˜ ëˆˆ
                const conEyeMaterial = new THREE.MeshToonMaterial({ 
                    color: 0x000000,
                    roughness: 0.3
                });
                
                const conLeftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 12, 12),
                    conEyeMaterial
                );
                conLeftEye.position.set(0.32, 0.1, 0.12);
                con.add(conLeftEye);
                
                const conRightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.04, 12, 12),
                    conEyeMaterial
                );
                conRightEye.position.set(0.32, 0.1, -0.12);
                con.add(conRightEye);
                
                // ì½˜ ê¼¬ë¦¬
                const conTail = new THREE.Mesh(
                    new THREE.ConeGeometry(0.08, 0.2, 12),
                    new THREE.MeshToonMaterial({ 
                        color: 0x00FF00,
                        roughness: 0.7
                    })
                );
                conTail.rotation.z = -Math.PI / 2;
                conTail.position.set(-0.3, 0, 0);
                conTail.castShadow = true;
                con.add(conTail);
                
                // ì½˜ ë“± í†±ë‹ˆ (ì‘ì€ ì‚¼ê°í˜•ë“¤)
                for (let i = 0; i < 3; i++) {
                    const spike = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, 0.1, 3),
                        new THREE.MeshToonMaterial({ 
                            color: 0x00cc00,
                            roughness: 0.7
                        })
                    );
                    spike.position.set(-0.05 + i * 0.1, 0.18, 0);
                    spike.castShadow = true;
                    con.add(spike);
                }
                
                con.position.set(0.8, 0, 0.3);
                con.scale.set(0.8, 0.8, 0.8);
                muzi.add(con);
                
                this.player.add(muzi);
                this.player.userData.character = muzi;
            }

            // ğŸ‘ ì–´í”¼ì¹˜ - ë³µìˆ­ì•„ ë¨¸ë¦¬
            createApeach() {
                const apeach = new THREE.Group();
                apeach.name = 'apeach';
                
                // === HEAD (ë³µìˆ­ì•„ ëª¨ì–‘) ===
                const head = new THREE.Group();
                head.name = 'head';
                
                // ë³µìˆ­ì•„ ë¨¸ë¦¬ (í•˜íŠ¸ ëª¨ì–‘ì— ê°€ê¹ê²Œ)
                const headTop = new THREE.Mesh(
                    new THREE.SphereGeometry(0.7, 32, 32, 0, Math.PI * 2, 0, Math.PI * 0.7),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFB6C1, // ë¶„í™ìƒ‰
                        roughness: 0.7,
                        metalness: 0.0
                    })
                );
                headTop.position.y = 0.1;
                headTop.castShadow = true;
                headTop.receiveShadow = true;
                head.add(headTop);
                
                const headBottom = new THREE.Mesh(
                    new THREE.SphereGeometry(0.65, 32, 32),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFB6C1,
                        roughness: 0.7
                    })
                );
                headBottom.scale.set(1, 0.9, 0.95);
                headBottom.position.y = -0.2;
                headBottom.castShadow = true;
                head.add(headBottom);
                
                // ë³µìˆ­ì•„ ì (ì´ˆë¡ìƒ‰)
                const leaf = new THREE.Mesh(
                    new THREE.ConeGeometry(0.25, 0.5, 12),
                    new THREE.MeshToonMaterial({ 
                        color: 0x4caf50,
                        roughness: 0.7,
                        emissive: 0x2e7d32,
                        emissiveIntensity: 0.2
                    })
                );
                leaf.position.set(0.15, 0.8, 0);
                leaf.rotation.z = -0.3;
                leaf.castShadow = true;
                head.add(leaf);
                
                // ëˆˆ (ì¥ë‚œìŠ¤ëŸ¬ìš´ - ìœ™í¬)
                const eyeMaterial = new THREE.MeshToonMaterial({ 
                    color: 0x000000,
                    roughness: 0.3
                });
                
                // ì™¼ìª½ ëˆˆ (ìœ™í¬ - ì„ ìœ¼ë¡œ)
                const leftEyeShape = new THREE.Shape();
                leftEyeShape.moveTo(-0.12, 0);
                leftEyeShape.lineTo(0.12, 0);
                
                const leftEye = new THREE.Mesh(
                    new THREE.ShapeGeometry(leftEyeShape),
                    eyeMaterial
                );
                leftEye.position.set(-0.22, 0.05, 0.62);
                head.add(leftEye);
                
                // ì˜¤ë¥¸ìª½ ëˆˆ (ì—´ë¦° ëˆˆ)
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 16, 16),
                    eyeMaterial
                );
                rightEye.position.set(0.22, 0.05, 0.62);
                head.add(rightEye);
                
                // ë°œê·¸ë ˆí•œ ë³¼
                const cheekMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xFF69B4, // ì§„ë¶„í™
                    roughness: 0.5,
                    emissive: 0xFF69B4,
                    emissiveIntensity: 0.3
                });
                
                const leftCheek = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    cheekMaterial
                );
                leftCheek.position.set(-0.4, -0.1, 0.55);
                leftCheek.scale.set(1, 0.7, 0.4);
                head.add(leftCheek);
                
                const rightCheek = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 16, 16),
                    cheekMaterial
                );
                rightCheek.position.set(0.4, -0.1, 0.55);
                rightCheek.scale.set(1, 0.7, 0.4);
                head.add(rightCheek);
                
                // ì… (ì›ƒëŠ” ê³¡ì„ )
                const mouthShape = new THREE.Shape();
                mouthShape.moveTo(-0.2, 0);
                mouthShape.quadraticCurveTo(0, -0.12, 0.2, 0);
                
                const mouth = new THREE.Mesh(
                    new THREE.ShapeGeometry(mouthShape),
                    new THREE.MeshToonMaterial({ 
                        color: 0x000000,
                        side: THREE.DoubleSide
                    })
                );
                mouth.position.set(0, -0.25, 0.6);
                head.add(mouth);
                
                head.position.y = 1;
                apeach.add(head);
                
                // === BODY ===
                const body = new THREE.Group();
                body.name = 'body';
                
                const bodyMesh = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.48, 0.9, 20, 32),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFB6C1,
                        roughness: 0.7,
                        metalness: 0.0
                    })
                );
                bodyMesh.castShadow = true;
                bodyMesh.receiveShadow = true;
                body.add(bodyMesh);
                
                body.position.y = 0;
                apeach.add(body);
                
                // === ARMS ===
                const arms = new THREE.Group();
                arms.name = 'arms';
                
                const armMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xFFB6C1,
                    roughness: 0.7
                });
                
                const leftArm = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.14, 0.55, 12, 16),
                    armMaterial
                );
                leftArm.position.set(-0.52, 0.25, 0);
                leftArm.rotation.z = 0.35;
                leftArm.castShadow = true;
                leftArm.name = 'leftArm';
                arms.add(leftArm);
                
                const rightArm = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.14, 0.55, 12, 16),
                    armMaterial
                );
                rightArm.position.set(0.52, 0.25, 0);
                rightArm.rotation.z = -0.35;
                rightArm.castShadow = true;
                rightArm.name = 'rightArm';
                arms.add(rightArm);
                
                apeach.add(arms);
                
                // === LEGS (ì„¹ì‹œí•œ ë’¤íƒœ ê°•ì¡°) ===
                const legs = new THREE.Group();
                legs.name = 'legs';
                
                const legMaterial = new THREE.MeshToonMaterial({ 
                    color: 0xFFB6C1,
                    roughness: 0.7
                });
                
                const leftLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.17, 0.5, 12, 16),
                    legMaterial
                );
                leftLeg.position.set(-0.22, -0.7, 0);
                leftLeg.castShadow = true;
                leftLeg.name = 'leftLeg';
                legs.add(leftLeg);
                
                const rightLeg = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.17, 0.5, 12, 16),
                    legMaterial
                );
                rightLeg.position.set(0.22, -0.7, 0);
                rightLeg.castShadow = true;
                rightLeg.name = 'rightLeg';
                legs.add(rightLeg);
                
                apeach.add(legs);
                
                // === BUTT (ê·€ì—¬ìš´ ë’¤íƒœ ê°•ì¡°) ===
                const butt = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 24, 24),
                    new THREE.MeshToonMaterial({ 
                        color: 0xFFB6C1,
                        roughness: 0.7
                    })
                );
                butt.scale.set(1.2, 0.9, 0.8);
                butt.position.set(0, -0.3, -0.3);
                butt.castShadow = true;
                apeach.add(butt);
                
                this.player.add(apeach);
                this.player.userData.character = apeach;
            }

            // ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜ (Idle & Walk)
            animateCharacter() {
                if (!this.player.userData.character) return;
                
                const character = this.player.userData.character;
                const time = this.time;
                const isMoving = this.keyState.KeyW || this.keyState.KeyS || this.keyState.KeyA || this.keyState.KeyD;
                
                // Head Bobbing (ìˆ¨ì‰¬ê¸°)
                const head = character.getObjectByName('head');
                if (head) {
                    if (isMoving) {
                        head.position.y = 1 + Math.sin(time * 8) * 0.05;
                        head.rotation.z = Math.sin(time * 8) * 0.05;
                    } else {
                        head.position.y = 1 + Math.sin(time * 2) * 0.02;
                    }
                }
                
                // Body Bobbing
                const body = character.getObjectByName('body');
                if (body && isMoving) {
                    body.position.y = Math.sin(time * 8) * 0.03;
                }
                
                // Arms & Legs Swing
                const arms = character.getObjectByName('arms');
                const legs = character.getObjectByName('legs');
                
                if (isMoving) {
                    // ê±·ê¸° ì• ë‹ˆë©”ì´ì…˜
                    if (arms) {
                        const leftArm = arms.getObjectByName('leftArm');
                        const rightArm = arms.getObjectByName('rightArm');
                        
                        if (leftArm) leftArm.rotation.x = Math.sin(time * 8) * 0.5;
                        if (rightArm) rightArm.rotation.x = -Math.sin(time * 8) * 0.5;
                    }
                    
                    if (legs) {
                        const leftLeg = legs.getObjectByName('leftLeg');
                        const rightLeg = legs.getObjectByName('rightLeg');
                        
                        if (leftLeg) leftLeg.rotation.x = Math.sin(time * 8) * 0.4;
                        if (rightLeg) rightLeg.rotation.x = -Math.sin(time * 8) * 0.4;
                    }
                } else {
                    // Idle ì• ë‹ˆë©”ì´ì…˜ (ì›ìœ„ì¹˜)
                    if (arms) {
                        const leftArm = arms.getObjectByName('leftArm');
                        const rightArm = arms.getObjectByName('rightArm');
                        
                        if (leftArm) leftArm.rotation.x = Math.sin(time * 2) * 0.1;
                        if (rightArm) rightArm.rotation.x = -Math.sin(time * 2) * 0.1;
                    }
                    
                    if (legs) {
                        const leftLeg = legs.getObjectByName('leftLeg');
                        const rightLeg = legs.getObjectByName('rightLeg');
                        
                        if (leftLeg) leftLeg.rotation.x = 0;
                        if (rightLeg) rightLeg.rotation.x = 0;
                    }
                }
                
                // ê¼¬ë¦¬ í”ë“¤ê¸° (ë¼ì´ì–¸)
                if (character.name === 'ryan') {
                    const tail = character.getObjectByName('tail');
                    if (tail) {
                        tail.rotation.y = Math.sin(time * 3) * 0.3;
                    }
                }
                
                // ì½˜ ì• ë‹ˆë©”ì´ì…˜ (ë¬´ì§€)
                if (character.name === 'muzi') {
                    const con = character.getObjectByName('con');
                    if (con) {
                        con.position.y = Math.sin(time * 4) * 0.05;
                        con.rotation.z = Math.sin(time * 3) * 0.1;
                    }
                }
            }

            setupControls() {
                // âŒ¨ï¸ WASD í‚¤ë³´ë“œ ì…ë ¥ (PC ê²Œì„ í‘œì¤€)
                window.addEventListener('keydown', (e) => {
                    // KeyboardEvent.codeë¡œ ì •í™•í•œ í‚¤ ì¸ì‹
                    if (this.keyState.hasOwnProperty(e.code)) {
                        this.keyState[e.code] = true;
                    }
                    
                    // ì í”„ (Space)
                    if (e.code === 'Space' && this.isGrounded) {
                        this.jumpVelocity = this.jumpPower;
                        this.isGrounded = false;
                        e.preventDefault(); // ìŠ¤í˜ì´ìŠ¤ë°” ìŠ¤í¬ë¡¤ ë°©ì§€
                    }
                    
                    // ìºë¦­í„° ë³€ê²½ (Digit1, Digit2, Digit3)
                    if (e.code === 'Digit1') {
                        this.currentCharacter = 'ryan';
                        this.createCharacter('ryan');
                    }
                    if (e.code === 'Digit2') {
                        this.currentCharacter = 'muzi';
                        this.createCharacter('muzi');
                    }
                    if (e.code === 'Digit3') {
                        this.currentCharacter = 'apeach';
                        this.createCharacter('apeach');
                    }
                    
                    // ğŸ”« ì „íˆ¬ ëª¨ë“œ í† ê¸€ (KeyQ)
                    if (e.code === 'KeyQ') {
                        this.toggleCombatMode();
                    }
                });

                window.addEventListener('keyup', (e) => {
                    // í‚¤ ìƒíƒœ í•´ì œ
                    if (this.keyState.hasOwnProperty(e.code)) {
                        this.keyState[e.code] = false;
                    }
                });

                const canvas = document.getElementById('gameCanvas');
                
                // ğŸ–±ï¸ ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ (ëª¨ë“œë³„ ì™„ì „ ë¶„ë¦¬!)
                canvas.addEventListener('mousedown', (e) => {
                    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    // ğŸ”« ì „íˆ¬ ëª¨ë“œ: ì¢Œí´ë¦­ = ë°œì‚¬
                    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    if (this.combatMode && e.button === 0) {
                        this.shoot();
                        console.log('ğŸ”« ì „íˆ¬ ëª¨ë“œ: ë°œì‚¬!');
                        return; // ë‹¤ë¥¸ ë™ì‘ ì°¨ë‹¨
                    }
                    
                    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    // ğŸ—ï¸ ê±´ì¶•/ì œê±° ëª¨ë“œ: ì¢Œí´ë¦­ = ë¸”ë¡ ë°°ì¹˜/ì œê±°
                    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    if (!this.combatMode && e.button === 0) {
                        this.handleBlockInteraction(e);
                        if (this.buildMode) {
                            console.log('ğŸ—ï¸ ê±´ì¶• ëª¨ë“œ: ë¸”ë¡ ë°°ì¹˜!');
                        } else {
                            console.log('ğŸ—‘ï¸ ì œê±° ëª¨ë“œ: ë¸”ë¡ ì œê±°!');
                        }
                        return; // ë‹¤ë¥¸ ë™ì‘ ì°¨ë‹¨
                    }
                    
                    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    // ğŸ¥ ì¹´ë©”ë¼ íšŒì „: ìš°í´ë¦­ ë“œë˜ê·¸
                    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    if (e.button === 2) { // ìš°í´ë¦­ë§Œ
                        this.mouseDown = true;
                        this.mousePos = { x: e.clientX, y: e.clientY };
                        canvas.style.cursor = 'grabbing';
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (this.mouseDown) {
                        const deltaX = e.clientX - this.mousePos.x;
                        const deltaY = e.clientY - this.mousePos.y;
                        
                        // ì¹´ë©”ë¼ ìˆ˜í‰/ìˆ˜ì§ íšŒì „
                        this.cameraAngle.horizontal -= deltaX * 0.005;
                        this.cameraAngle.vertical -= deltaY * 0.003;
                        
                        // ìˆ˜ì§ ê°ë„ ì œí•œ (ë„ˆë¬´ ìœ„/ì•„ë˜ ì•ˆ ë³´ê²Œ)
                        this.cameraAngle.vertical = Math.max(-0.5, Math.min(1.2, this.cameraAngle.vertical));
                        
                        this.mousePos = { x: e.clientX, y: e.clientY };
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    this.mouseDown = false;
                    canvas.style.cursor = 'default';
                });

                canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });

                // ğŸ” ì¤Œ ì¸/ì•„ì›ƒ (ë§ˆìš°ìŠ¤ íœ )
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.cameraDistance += e.deltaY * 0.01;
                    this.cameraDistance = Math.max(2, Math.min(15, this.cameraDistance)); // ìµœì†Œ 2 ~ ìµœëŒ€ 15
                });

                document.querySelectorAll('.character-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.character-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentCharacter = e.target.dataset.char;
                        this.createCharacter(this.currentCharacter);
                    });
                });

                document.getElementById('buildMode').addEventListener('click', () => {
                    this.buildMode = true;
                    document.getElementById('buildMode').classList.add('active');
                    document.getElementById('removeMode').classList.remove('active');
                });

                document.getElementById('removeMode').addEventListener('click', () => {
                    this.buildMode = false;
                    document.getElementById('removeMode').classList.add('active');
                    document.getElementById('buildMode').classList.remove('active');
                });

                document.querySelectorAll('.block-option').forEach(opt => {
                    opt.addEventListener('click', (e) => {
                        document.querySelectorAll('.block-option').forEach(o => o.classList.remove('active'));
                        e.target.classList.add('active');
                        this.selectedBlock = e.target.dataset.block;
                    });
                });

                // 3D ëª¨ë¸ ëª¨ë“œ ë²„íŠ¼
                document.getElementById('modelMode').addEventListener('click', () => {
                    this.buildMode = false;
                    document.getElementById('buildMode').classList.remove('active');
                    document.getElementById('removeMode').classList.remove('active');
                    document.getElementById('modelMode').classList.add('active');
                    document.getElementById('modelPanel').style.display = 'block';
                });

                document.getElementById('buildMode').addEventListener('click', () => {
                    document.getElementById('modelPanel').style.display = 'none';
                });

                document.getElementById('removeMode').addEventListener('click', () => {
                    document.getElementById('modelPanel').style.display = 'none';
                });

                // ğŸ”« ì „íˆ¬ ëª¨ë“œ ë²„íŠ¼
                document.getElementById('combatModeBtn').addEventListener('click', () => {
                    this.toggleCombatMode();
                });
            }

            // ğŸ”« ì „íˆ¬ ëª¨ë“œ í† ê¸€
            toggleCombatMode() {
                this.combatMode = !this.combatMode;
                
                // UI ì—…ë°ì´íŠ¸
                const crosshair = document.getElementById('crosshair');
                const combatModeUI = document.getElementById('combatMode');
                const combatBtn = document.getElementById('combatModeBtn');
                
                if (this.combatMode) {
                    // ì „íˆ¬ ëª¨ë“œ ON
                    crosshair.classList.add('active');
                    combatModeUI.classList.add('active');
                    combatBtn.classList.add('active');
                    this.weapon.visible = true;
                    
                    // ê±´ì¶• ëª¨ë“œ ë¹„í™œì„±í™”
                    this.buildMode = false;
                    document.getElementById('buildMode').classList.remove('active');
                    document.getElementById('removeMode').classList.remove('active');
                    
                    // ğŸ ë””ë²„ê¹… ë¡œê·¸
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('ğŸ”«ğŸ”«ğŸ”« ì „íˆ¬ ëª¨ë“œ í™œì„±í™”! ğŸ”«ğŸ”«ğŸ”«');
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('âœ… ì´ ë³´ì„:', this.weapon.visible);
                    console.log('âœ… ì´ ìœ„ì¹˜:', this.weapon.position);
                    console.log('âœ… ì´ í¬ê¸°:', this.weapon.scale);
                    console.log('âœ… ì¡°ì¤€ì  í™œì„±í™”:', crosshair.classList.contains('active'));
                    console.log('ğŸ’¡ ì¢Œí´ë¦­ìœ¼ë¡œ ë°œì‚¬í•˜ì„¸ìš”!');
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                } else {
                    // ì „íˆ¬ ëª¨ë“œ OFF
                    crosshair.classList.remove('active');
                    combatModeUI.classList.remove('active');
                    combatBtn.classList.remove('active');
                    this.weapon.visible = false;
                    
                    console.log('ğŸ”¨ ê±´ì¶• ëª¨ë“œë¡œ ì „í™˜');
                }
            }

            // ğŸ”« ë°œì‚¬ (Shoot) - í˜•ê´‘ ë…¸ë€ìƒ‰ ì´ì•Œ + ì‚¬ìš´ë“œ!
            shoot() {
                const currentTime = Date.now();
                
                // ë°œì‚¬ ì†ë„ ì œí•œ (ì—°ì‚¬ ë°©ì§€)
                if (currentTime - this.lastShotTime < this.fireRate) {
                    return;
                }
                this.lastShotTime = currentTime;
                
                // ğŸ”Š ë°œì‚¬ íš¨ê³¼ìŒ ì¬ìƒ!
                this.playShootSound();
                
                // ğŸ’¥ í˜•ê´‘ ë…¸ë€ìƒ‰ ì´ì•Œ ìƒì„± (ì–´ë‘ìš´ ê³³ì—ì„œë„ ë¹›ë‚¨!)
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 16, 16), // ë°˜ì§€ë¦„ 0.2
                    new THREE.MeshBasicMaterial({
                        color: 0xFFFF00, // í˜•ê´‘ ë…¸ë€ìƒ‰
                        wireframe: false
                    })
                );
                
                // ğŸ¯ ë°œì‚¬ ìœ„ì¹˜: ì´êµ¬ ë§ˆì»¤(ì´ˆë¡ìƒ‰)ì˜ ì›”ë“œ ì¢Œí‘œ!
                const startPos = new THREE.Vector3();
                if (this.muzzleFlash) {
                    this.muzzleFlash.getWorldPosition(startPos);
                } else {
                    // Fallback: ìºë¦­í„° ë¨¸ë¦¬ ìœ„ + ì•ìª½
                    startPos.copy(this.player.position);
                    startPos.y += 2.0;
                    const cameraDir = new THREE.Vector3();
                    this.camera.getWorldDirection(cameraDir);
                    startPos.add(cameraDir.multiplyScalar(1.5));
                }
                
                bullet.position.copy(startPos);
                bullet.castShadow = true;
                
                // ğŸ§­ ì¹´ë©”ë¼ê°€ ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ ë°œì‚¬ (TPS í‘œì¤€)
                const direction = new THREE.Vector3();
                this.camera.getWorldDirection(direction);
                direction.normalize();
                
                // ì´ì•Œ ì†ë„: 1.0 (ë¹ ë¥´ê²Œ!)
                const bulletVelocity = direction.clone().multiplyScalar(1.0);
                
                // ì´ì•Œ ë°ì´í„°
                bullet.userData = {
                    velocity: bulletVelocity,
                    createdAt: currentTime,
                    lifetime: this.bulletLifetime
                };
                
                this.scene.add(bullet);
                this.bullets.push(bullet);
                
                // ğŸ ë””ë²„ê¹… ë¡œê·¸
                console.log('ğŸ’¥ğŸ’¥ğŸ’¥ BANG! ì´ì•Œ ë°œì‚¬!');
                console.log('   ìœ„ì¹˜:', `x:${startPos.x.toFixed(2)}, y:${startPos.y.toFixed(2)}, z:${startPos.z.toFixed(2)}`);
                console.log('   ë°©í–¥:', `x:${direction.x.toFixed(2)}, y:${direction.y.toFixed(2)}, z:${direction.z.toFixed(2)}`);
                console.log('   ì†ë„:', bulletVelocity);
                console.log('   ì´ ì´ì•Œ ìˆ˜:', this.bullets.length);
                
                // ğŸ’¥ ë°˜ë™ ì• ë‹ˆë©”ì´ì…˜
                if (this.weapon.visible) {
                    const originalZ = this.weapon.position.z;
                    this.weapon.position.z += 0.2;
                    setTimeout(() => {
                        this.weapon.position.z = originalZ;
                    }, 100);
                }
                
                // ğŸ”Š ì½˜ì†”ì— í° ì•Œë¦¼
                console.log('ğŸ”«ğŸ”«ğŸ”« ì´ì•Œì´ ë‚ ì•„ê°‘ë‹ˆë‹¤! í™”ë©´ì„ ì£¼ëª©í•˜ì„¸ìš”! ğŸ”«ğŸ”«ğŸ”«');
            }

            // ğŸ’¨ ì´ì•Œ ì—…ë°ì´íŠ¸ (ì´ë™ + ìˆ˜ëª… ê´€ë¦¬)
            updateBullets() {
                const currentTime = Date.now();
                const bulletsToRemove = [];
                
                for (let i = 0; i < this.bullets.length; i++) {
                    const bullet = this.bullets[i];
                    const userData = bullet.userData;
                    
                    // ì´ì•Œ ì´ë™ (ë§¤ í”„ë ˆì„)
                    bullet.position.add(userData.velocity);
                    
                    // ìƒëª… ì‹œê°„ ì²´í¬ (2ì´ˆ í›„ ì œê±°)
                    if (currentTime - userData.createdAt > userData.lifetime) {
                        bulletsToRemove.push(i);
                        continue;
                    }
                    
                    // ë§µ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
                    const limit = this.villageSize / 2;
                    if (Math.abs(bullet.position.x) > limit || 
                        Math.abs(bullet.position.z) > limit ||
                        bullet.position.y < 0 || bullet.position.y > 100) {
                        bulletsToRemove.push(i);
                    }
                }
                
                // ì´ì•Œ ì œê±° (ì—­ìˆœìœ¼ë¡œ)
                for (let i = bulletsToRemove.length - 1; i >= 0; i--) {
                    const index = bulletsToRemove[i];
                    const bullet = this.bullets[index];
                    this.scene.remove(bullet);
                    bullet.geometry.dispose();
                    bullet.material.dispose();
                    this.bullets.splice(index, 1);
                }
            }

            // ğŸ’¥ ì¶©ëŒ ê°ì§€ (ì´ì•Œ vs ìŠ¬ë¼ì„)
            checkCollisions() {
                const bulletsToRemove = [];
                const monstersToRemove = [];
                
                // ëª¨ë“  ì´ì•Œ vs ëª¨ë“  ëª¬ìŠ¤í„° ì²´í¬
                for (let i = 0; i < this.bullets.length; i++) {
                    const bullet = this.bullets[i];
                    
                    for (let j = 0; j < this.monsters.length; j++) {
                        const monster = this.monsters[j];
                        
                        // ê±°ë¦¬ ê³„ì‚°
                        const distance = bullet.position.distanceTo(monster.position);
                        const hitRadius = monster.userData.radius + 0.2; // ì´ì•Œ ë°˜ì§€ë¦„ í¬í•¨
                        
                        // ì¶©ëŒ íŒì •!
                        if (distance < hitRadius) {
                            // ì¶©ëŒ íš¨ê³¼
                            bulletsToRemove.push(i);
                            monstersToRemove.push(j);
                            
                            // ğŸ‰ íŒŒí‹°í´ íš¨ê³¼ (ê°„ë‹¨í•œ í­ë°œ)
                            this.createHitEffect(monster.position);
                            
                            // ë¡œê·¸
                            console.log('ğŸ’¥ ìŠ¬ë¼ì„ ì²˜ì¹˜! ë‚¨ì€ ìŠ¬ë¼ì„:', this.monsters.length - 1);
                            
                            break; // ì´ ì´ì•Œì€ ì´ë¯¸ ì¶©ëŒí–ˆìœ¼ë¯€ë¡œ ë‹¤ìŒ ì´ì•Œë¡œ
                        }
                    }
                }
                
                // ì¶©ëŒí•œ ì´ì•Œ ì œê±° (ì—­ìˆœ)
                for (let i = bulletsToRemove.length - 1; i >= 0; i--) {
                    const index = bulletsToRemove[i];
                    if (this.bullets[index]) {
                        const bullet = this.bullets[index];
                        this.scene.remove(bullet);
                        bullet.geometry.dispose();
                        bullet.material.dispose();
                        this.bullets.splice(index, 1);
                    }
                }
                
                // ì¶©ëŒí•œ ëª¬ìŠ¤í„° ì œê±° (ì—­ìˆœ)
                for (let i = monstersToRemove.length - 1; i >= 0; i--) {
                    const index = monstersToRemove[i];
                    if (this.monsters[index]) {
                        const monster = this.monsters[index];
                        this.scene.remove(monster);
                        this.monsters.splice(index, 1);
                    }
                }
                
                // ëª¨ë“  ìŠ¬ë¼ì„ ì²˜ì¹˜ ì‹œ
                if (this.monsters.length === 0) {
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    console.log('ğŸ‰ğŸ‰ğŸ‰ ëª¨ë“  ìŠ¬ë¼ì„ ì²˜ì¹˜ ì™„ë£Œ! ğŸ‰ğŸ‰ğŸ‰');
                    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                    
                    // 3ì´ˆ í›„ ìƒˆë¡œìš´ ìŠ¬ë¼ì„ ì†Œí™˜
                    setTimeout(() => {
                        this.spawnMonsters();
                    }, 3000);
                }
            }

            // ğŸ‰ í”¼ê²© íš¨ê³¼ (ê°„ë‹¨í•œ íŒŒí‹°í´)
            createHitEffect(position) {
                // ì´ˆë¡ìƒ‰ íŒŒí‹°í´ 5ê°œ ìƒì„±
                for (let i = 0; i < 5; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x00FF00 })
                    );
                    
                    particle.position.copy(position);
                    
                    // ëœë¤ ë°©í–¥ìœ¼ë¡œ íŠ€ê¹€
                    const velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        Math.random() * 0.3,
                        (Math.random() - 0.5) * 0.3
                    );
                    
                    particle.userData = {
                        velocity: velocity,
                        createdAt: Date.now(),
                        lifetime: 500 // 0.5ì´ˆ
                    };
                    
                    this.scene.add(particle);
                    this.bullets.push(particle); // bullets ë°°ì—´ì— ì¶”ê°€ (ê°™ì€ ì‹œìŠ¤í…œìœ¼ë¡œ ê´€ë¦¬)
                }
            }

            // ğŸ—ï¸ 3D ëª¨ë¸ ë¡œë” ì‹œìŠ¤í…œ
            // ğŸ—ï¸ BIM ëª¨ë¸ UI ì„¤ì •
            setupModelLoaders() {
                const fileInput = document.getElementById('modelFileInput');
                const scaleSlider = document.getElementById('modelScale');
                const rotationSlider = document.getElementById('modelRotation');
                
                // íŒŒì¼ ì„ íƒ
                fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadModelFile(file);
                    }
                });

                // í¬ê¸° ì¡°ì ˆ
                scaleSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.modelScale = value;
                    if (this.modelPreview) {
                        this.modelPreview.scale.set(value, value, value);
                    }
                });

                // íšŒì „ ì¡°ì ˆ
                rotationSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.modelRotation = value * (Math.PI / 180);
                    if (this.modelPreview) {
                        this.modelPreview.rotation.y = this.modelRotation;
                    }
                });

                // ë°°ì¹˜ ë²„íŠ¼
                document.getElementById('placeModel').addEventListener('click', () => {
                    if (this.modelPreview) {
                        this.placeCurrentModel();
                    }
                });

                // ì·¨ì†Œ ë²„íŠ¼
                document.getElementById('cancelModel').addEventListener('click', () => {
                    this.cancelModelPreview();
                });
            }

            // âŒ ëª¨ë¸ í”„ë¦¬ë·° ì·¨ì†Œ
            cancelModelPreview() {
                if (this.modelPreview) {
                    this.scene.remove(this.modelPreview);
                    this.modelPreview = null;
                    this.currentModel = null;
                }
                
                document.getElementById('modelControls').style.display = 'none';
                document.getElementById('modelFileInput').value = '';
                document.getElementById('modelScale').value = 1;
                document.getElementById('modelRotation').value = 0;
                
                console.log('âŒ ëª¨ë¸ í”„ë¦¬ë·° ì·¨ì†Œë¨');
            }

            // íŒŒì¼ ë¡œë“œ
            loadModelFile(file) {
                const fileName = file.name;
                const fileExtension = fileName.split('.').pop().toLowerCase();
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    const contents = e.target.result;
                    
                    if (fileExtension === 'glb' || fileExtension === 'gltf') {
                        this.loadGLTF(contents, fileName);
                    } else if (fileExtension === 'obj') {
                        this.loadOBJ(contents, fileName);
                    }
                };
                
                if (fileExtension === 'glb') {
                    reader.readAsArrayBuffer(file);
                } else {
                    reader.readAsText(file);
                }
            }

            // ğŸ¨ GLB/GLTF ë¡œë“œ (ES Module ë°©ì‹)
            loadGLTF(data, fileName, isBinary = true) {
                console.log(`ğŸ¨ GLTF íŒŒì‹± ì‹œì‘: ${fileName}`);
                
                const loader = this.gltfLoader;
                
                const onLoad = (gltf) => {
                    console.log('âœ… GLTF ë¡œë“œ ì„±ê³µ!');
                    this.prepareModel(gltf.scene, fileName);
                };
                
                const onError = (error) => {
                    console.error('âŒ GLTF ë¡œë“œ ì˜¤ë¥˜:', error);
                    alert(`GLB/GLTF íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì˜¤ë¥˜: ${error.message}`);
                };
                
                loader.parse(data, '', onLoad, onError);
            }

            // ğŸ“ OBJ ë¡œë“œ (ES Module ë°©ì‹)
            loadOBJ(data, fileName) {
                console.log(`ğŸ“ OBJ íŒŒì‹± ì‹œì‘: ${fileName}`);
                
                const loader = this.objLoader;
                
                try {
                    const model = loader.parse(data);
                    console.log('âœ… OBJ ë¡œë“œ ì„±ê³µ!');
                    this.prepareModel(model, fileName);
                } catch (error) {
                    console.error('âŒ OBJ ë¡œë“œ ì˜¤ë¥˜:', error);
                    alert(`OBJ íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\nì˜¤ë¥˜: ${error.message}`);
                }
            }

            // ğŸ”§ ëª¨ë¸ ì¤€ë¹„ (BIM ìµœì í™”)
            prepareModel(model, fileName) {
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                console.log('ğŸ”§ BIM ëª¨ë¸ ìë™ ìŠ¤ì¼€ì¼ë§ ì‹œì‘...');
                console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
                
                // ê¸°ì¡´ í”„ë¦¬ë·° ì œê±°
                if (this.modelPreview) {
                    this.scene.remove(this.modelPreview);
                }

                // ğŸ“ 1ë‹¨ê³„: ë°”ìš´ë”© ë°•ìŠ¤ ì¸¡ì •
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());
                
                console.log(`ğŸ“ ì›ë³¸ í¬ê¸° (Original Size):`);
                console.log(`   Width (X):  ${size.x.toFixed(4)} units`);
                console.log(`   Height (Y): ${size.y.toFixed(4)} units â† ì´ ê°’ì´ ì¤‘ìš”!`);
                console.log(`   Depth (Z):  ${size.z.toFixed(4)} units`);
                console.log(`   Center: (${center.x.toFixed(2)}, ${center.y.toFixed(2)}, ${center.z.toFixed(2)})`);
                
                // ğŸ¯ 2ë‹¨ê³„: íƒ€ê²Ÿ ë†’ì´ ê¸°ì¤€ ìŠ¤ì¼€ì¼ ê³„ì‚°
                const targetHeight = 2.0; // ì‚¬ëŒ í‚¤ (2ë¯¸í„°)
                const originalHeight = size.y;
                const scaleFactor = targetHeight / originalHeight;
                
                console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
                console.log(`ğŸ¯ ìë™ ìŠ¤ì¼€ì¼ë§ ê³„ì‚°:`);
                console.log(`   Original Model Height: ${originalHeight.toFixed(4)} units`);
                console.log(`   Target Height: ${targetHeight.toFixed(2)} units (ì‚¬ëŒ í‚¤)`);
                console.log(`   âš¡ Applied Scale Factor: ${scaleFactor.toFixed(2)}x`);
                
                if (scaleFactor > 1000) {
                    console.log(`   âš ï¸ ê²½ê³ : ëª¨ë¸ì´ ê·¹ë„ë¡œ ì‘ìŠµë‹ˆë‹¤! (${scaleFactor.toFixed(0)}ë°° í™•ëŒ€)`);
                    console.log(`   ğŸ’¡ ì›ë³¸ ëª¨ë¸ ë‹¨ìœ„ë¥¼ í™•ì¸í•˜ì„¸ìš” (mm â†’ m ë³€í™˜ í•„ìš”?)`);
                } else if (scaleFactor < 0.001) {
                    console.log(`   âš ï¸ ê²½ê³ : ëª¨ë¸ì´ ê·¹ë„ë¡œ í½ë‹ˆë‹¤! (${(1/scaleFactor).toFixed(0)}ë°° ì¶•ì†Œ)`);
                }
                console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
                
                // ğŸ“ ìŠ¤ì¼€ì¼ ì ìš©
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                // ğŸ“ 3ë‹¨ê³„: ìœ„ì¹˜ ë³´ì • (ë°”ë‹¥ì— ë§ì¶”ê¸°)
                // ìŠ¤ì¼€ì¼ ì ìš© í›„ ë‹¤ì‹œ ë°”ìš´ë”© ë°•ìŠ¤ ê³„ì‚°
                box.setFromObject(model);
                const newSize = box.getSize(new THREE.Vector3());
                const newCenter = box.getCenter(new THREE.Vector3());
                
                // ì¤‘ì‹¬ì„ ì›ì ìœ¼ë¡œ
                model.position.x -= newCenter.x;
                model.position.z -= newCenter.z;
                
                // ë°”ë‹¥(min.y)ì„ y=0ì— ë§ì¶¤
                const minY = box.min.y;
                model.position.y = -minY;
                
                console.log(`ğŸ“ ìœ„ì¹˜ ë³´ì • ì™„ë£Œ:`);
                console.log(`   ì¡°ì • í›„ ë†’ì´: ${newSize.y.toFixed(2)} units (â‰ˆ${targetHeight.toFixed(2)}m)`);
                console.log(`   ë°”ë‹¥ Y ì¢Œí‘œ: ${model.position.y.toFixed(2)}`);

                // ğŸŒ‘ ê·¸ë¦¼ì & ì¬ì§ˆ ì„¤ì • (BIM ìµœì í™”)
                let meshCount = 0;
                model.traverse((child) => {
                    if (child.isMesh) {
                        meshCount++;
                        child.castShadow = true;
                        child.receiveShadow = true;
                        
                        // ì¬ì§ˆì´ ì—†ìœ¼ë©´ ê¸°ë³¸ ì¬ì§ˆ
                        if (!child.material) {
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xcccccc,
                                roughness: 0.7,
                                metalness: 0.2
                            });
                        }
                        
                        // âš¡ ì–‘ë©´ ë Œë”ë§ (BIM ë‹¨ë©´ í˜¸í™˜ì„±)
                        if (child.material) {
                            child.material.side = THREE.DoubleSide;
                        }
                    }
                });
                
                console.log(`âœ… ë©”ì‰¬ ${meshCount}ê°œ ìµœì í™” ì™„ë£Œ`);

                // ğŸ¯ í”Œë ˆì´ì–´ ì• 8mì— ë°°ì¹˜
                const playerPos = this.player.position.clone();
                const cameraAngle = this.cameraAngle.horizontal;
                model.position.x += playerPos.x + Math.sin(cameraAngle) * 8;
                model.position.z += playerPos.z + Math.cos(cameraAngle) * 8;

                this.scene.add(model);
                this.modelPreview = model;
                this.currentModel = {
                    name: fileName,
                    originalScale: scaleFactor
                };

                // UI í‘œì‹œ
                document.getElementById('modelControls').style.display = 'block';
                
                console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
                console.log(`âœ… ${fileName} í”„ë¦¬ë·° ì¤€ë¹„ ì™„ë£Œ!`);
                console.log(`   ìµœì¢… í¬ê¸°: ${newSize.x.toFixed(2)} x ${newSize.y.toFixed(2)} x ${newSize.z.toFixed(2)}`);
                console.log(`   ìµœì¢… ìœ„ì¹˜: (${model.position.x.toFixed(2)}, ${model.position.y.toFixed(2)}, ${model.position.z.toFixed(2)})`);
                console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
            }

            // ëª¨ë¸ ë°°ì¹˜
            placeCurrentModel() {
                if (this.modelPreview && this.currentModel) {
                    // ë°°ì¹˜ëœ ëª¨ë¸ë¡œ ì €ì¥
                    this.loadedModels.push({
                        name: this.currentModel.name,
                        model: this.modelPreview,
                        position: this.modelPreview.position.clone(),
                        rotation: this.modelPreview.rotation.clone(),
                        scale: this.modelPreview.scale.clone()
                    });

                    // ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                    this.updateModelList();

                    // í”„ë¦¬ë·° ì´ˆê¸°í™”
                    this.modelPreview = null;
                    this.currentModel = null;
                    
                    // UI ì´ˆê¸°í™”
                    document.getElementById('modelControls').style.display = 'none';
                    document.getElementById('modelFileInput').value = '';
                    document.getElementById('modelScale').value = 1;
                    document.getElementById('modelRotation').value = 0;
                    
                    console.log('âœ… ëª¨ë¸ ë°°ì¹˜ ì™„ë£Œ!');
                }
            }

            // ëª¨ë¸ ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            updateModelList() {
                const listElement = document.getElementById('loadedModels');
                listElement.innerHTML = '';
                
                this.loadedModels.forEach((item, index) => {
                    const li = document.createElement('li');
                    li.innerHTML = `
                        <span>${item.name}</span>
                        <button onclick="game.removeModel(${index})">ì‚­ì œ</button>
                    `;
                    listElement.appendChild(li);
                });
            }

            // ëª¨ë¸ ì œê±°
            removeModel(index) {
                const item = this.loadedModels[index];
                if (item && item.model) {
                    this.scene.remove(item.model);
                    this.loadedModels.splice(index, 1);
                    this.updateModelList();
                    console.log('ğŸ—‘ï¸ ëª¨ë¸ ì œê±°ë¨');
                }
            }

            handleBlockInteraction(event) {
                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObjects(this.scene.children, true);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const x = Math.floor(point.x / this.gridSize) * this.gridSize;
                    const y = Math.floor(point.y / this.gridSize) * this.gridSize + 0.5;
                    const z = Math.floor(point.z / this.gridSize) * this.gridSize;
                    const key = `${x},${y},${z}`;

                    if (this.buildMode && !this.world.has(key) && y >= 0) {
                        this.placeBlock(x, y, z, this.selectedBlock);
                    } else if (!this.buildMode && this.world.has(key)) {
                        this.removeBlock(key);
                    }
                }
            }

            placeBlock(x, y, z, type) {
                const colors = {
                    grass: 0x7ec850,
                    wood: 0xd2691e,
                    stone: 0xc0c0c0,
                    brick: 0xff6b6b
                };

                // âœ¨ MeshStandardMaterialë¡œ ëª¨ë“  ë¸”ë¡ ìƒì„±
                const block = new THREE.Mesh(
                    new THREE.BoxGeometry(this.gridSize, this.gridSize, this.gridSize),
                    new THREE.MeshStandardMaterial({ 
                        color: colors[type],
                        roughness: 0.7,
                        metalness: 0.2
                    })
                );
                
                block.position.set(x, y, z);
                block.castShadow = true;
                block.receiveShadow = true;
                
                const key = `${x},${y},${z}`;
                this.world.set(key, block);
                this.scene.add(block);
            }

            removeBlock(key) {
                const block = this.world.get(key);
                if (block) {
                    this.scene.remove(block);
                    this.world.delete(key);
                }
            }

            updatePlayer() {
                // ğŸƒ ë¬¼ë¦¬ ê¸°ë°˜ ë¶€ë“œëŸ¬ìš´ ì´ë™
                
                // ğŸ§­ 1ë‹¨ê³„: WASD ì…ë ¥ ìˆ˜ì§‘ (KeyboardEvent.code ê¸°ë°˜)
                const inputVector = new THREE.Vector3();
                if (this.keyState.KeyW) inputVector.z = 1;   // ì „ì§„ (Forward)
                if (this.keyState.KeyS) inputVector.z = -1;  // í›„ì§„ (Backward)
                if (this.keyState.KeyA) inputVector.x = -1;  // ì¢Œì¸¡ (Strafe Left)
                if (this.keyState.KeyD) inputVector.x = 1;   // ìš°ì¸¡ (Strafe Right)

                // ğŸ§­ 2ë‹¨ê³„: ì¹´ë©”ë¼ ê¸°ì¤€ ë°©í–¥ ê³„ì‚°
                if (inputVector.length() > 0) {
                    // ëŒ€ê°ì„  ì´ë™ ì •ê·œí™” (W+D ë™ì‹œ ì…ë ¥ ì‹œ ì†ë„ ì¦ê°€ ë°©ì§€)
                    inputVector.normalize();
                    
                    // ğŸ¥ ì¹´ë©”ë¼ê°€ ë³´ëŠ” ë°©í–¥ ê°€ì ¸ì˜¤ê¸° (getWorldDirection)
                    const cameraDirection = new THREE.Vector3();
                    this.camera.getWorldDirection(cameraDirection);
                    
                    // âš¡ Yì¶• ì œê±° (í‰ë©´ ì´ë™ë§Œ)
                    cameraDirection.y = 0;
                    cameraDirection.normalize();
                    
                    // ğŸ”„ ì¹´ë©”ë¼ì˜ ì˜¤ë¥¸ìª½ ë°©í–¥ ê³„ì‚° (Cross Product)
                    const cameraRight = new THREE.Vector3();
                    cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));
                    cameraRight.normalize();
                    
                    // ğŸ¯ ìµœì¢… ì´ë™ ë°©í–¥ = ì „ì§„/í›„ì§„ + ì¢Œ/ìš°
                    const moveDirection = new THREE.Vector3();
                    moveDirection.addScaledVector(cameraDirection, inputVector.z); // W/S
                    moveDirection.addScaledVector(cameraRight, inputVector.x);     // A/D
                    moveDirection.normalize();
                    
                    // âš¡ ê°€ì† (Acceleration)
                    this.velocity.x += moveDirection.x * this.acceleration;
                    this.velocity.z += moveDirection.z * this.acceleration;
                    
                    // ğŸš€ ìµœëŒ€ ì†ë„ ì œí•œ
                    const currentSpeed = Math.sqrt(this.velocity.x ** 2 + this.velocity.z ** 2);
                    if (currentSpeed > this.maxSpeed) {
                        this.velocity.x = (this.velocity.x / currentSpeed) * this.maxSpeed;
                        this.velocity.z = (this.velocity.z / currentSpeed) * this.maxSpeed;
                    }
                    
                    // ğŸ”„ ìºë¦­í„° íšŒì „ (ì´ë™ ë°©í–¥ì„ í–¥í•˜ê²Œ)
                    this.targetRotation = Math.atan2(moveDirection.x, moveDirection.z);
                    
                    // ë¶€ë“œëŸ¬ìš´ íšŒì „ ë³´ê°„ (Slerp ê·¼ì‚¬)
                    let currentRotation = this.player.rotation.y;
                    let rotationDiff = this.targetRotation - currentRotation;
                    
                    // -Ï€ ~ Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”
                    while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
                    while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
                    
                    // íšŒì „ ì ìš© (0.15 = íšŒì „ ì†ë„)
                    this.player.rotation.y += rotationDiff * 0.15;
                    
                    this.playerBounce += 0.25;
                } else {
                    // ğŸ›‘ ê°ì† (Friction/Damping)
                    this.velocity.x *= this.friction;
                    this.velocity.z *= this.friction;
                    
                    // ì•„ì£¼ ëŠë¦° ì†ë„ëŠ” 0ìœ¼ë¡œ
                    if (Math.abs(this.velocity.x) < 0.001) this.velocity.x = 0;
                    if (Math.abs(this.velocity.z) < 0.001) this.velocity.z = 0;
                    
                    this.playerBounce = 0;
                }

                // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                this.player.position.x += this.velocity.x;
                this.player.position.z += this.velocity.z;

                // ê²½ê³„ ì œí•œ
                const limit = this.villageSize / 2 - 5;
                this.player.position.x = Math.max(-limit, Math.min(limit, this.player.position.x));
                this.player.position.z = Math.max(-limit, Math.min(limit, this.player.position.z));

                // ğŸŒŠ ì í”„ ë° ì¤‘ë ¥ (ë¶€ë“œëŸ¬ìš´ í¬ë¬¼ì„ )
                if (!this.isGrounded) {
                    this.jumpVelocity -= this.gravity;
                    this.player.position.y += this.jumpVelocity;
                    
                    // ì°©ì§€
                    if (this.player.position.y <= 1) {
                        this.player.position.y = 1;
                        this.isGrounded = true;
                        this.jumpVelocity = 0;
                    }
                } else {
                    // ì§€ìƒì—ì„œ ê±·ê¸° ë°”ìš´ìŠ¤
                    const bounceOffset = Math.sin(this.playerBounce) * 0.08;
                    if (this.playerBounce > 0) {
                        this.player.position.y = 1 + bounceOffset;
                    } else {
                        this.player.position.y = 1;
                    }
                }
            }

            updateCamera() {
                // ğŸ¥ TPS ìˆ„ë”ë·° ì¹´ë©”ë¼ (ë¶€ë“œëŸ¬ìš´ ì¶”ì )
                
                const playerPos = this.player.position.clone();
                
                // ì¹´ë©”ë¼ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚° (ìºë¦­í„° ë“± ë’¤)
                const horizontalAngle = this.cameraAngle.horizontal;
                const verticalAngle = this.cameraAngle.vertical;
                const distance = this.cameraDistance;
                
                // êµ¬ë©´ ì¢Œí‘œê³„ë¡œ ì¹´ë©”ë¼ ìœ„ì¹˜ ê³„ì‚°
                const targetX = playerPos.x - Math.sin(horizontalAngle) * Math.cos(verticalAngle) * distance;
                const targetY = playerPos.y + Math.sin(verticalAngle) * distance + 1.5; // ìºë¦­í„° ë†’ì´ ì˜¤í”„ì…‹
                const targetZ = playerPos.z - Math.cos(horizontalAngle) * Math.cos(verticalAngle) * distance;
                
                const targetPosition = new THREE.Vector3(targetX, targetY, targetZ);
                
                // âœ¨ ë¶€ë“œëŸ¬ìš´ ì¶”ì  (Lerp) - ì•½ê°„ì˜ ì§€ì—°
                this.camera.position.lerp(targetPosition, 0.1);
                
                // ì¹´ë©”ë¼ê°€ ë°”ë¼ë³¼ ìœ„ì¹˜ (ìºë¦­í„° ìƒì²´)
                const lookAtTarget = playerPos.clone();
                lookAtTarget.y += 1; // ë¨¸ë¦¬ ë†’ì´
                
                // âœ¨ ì‹œì„ ë„ ë¶€ë“œëŸ½ê²Œ (Lerp)
                this.cameraLookAt.lerp(lookAtTarget, 0.15);
                this.camera.lookAt(this.cameraLookAt);
            }

            updateMinimap() {
                const canvas = document.getElementById('minimapCanvas');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                const size = canvas.width;
                const scale = size / this.villageSize;
                
                // ë°°ê²½
                const gradient = ctx.createLinearGradient(0, 0, size, size);
                gradient.addColorStop(0, '#b5ead7');
                gradient.addColorStop(1, '#c7ceea');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, size, size);
                
                // ì¤‘ì•™ ê´‘ì¥
                ctx.fillStyle = '#f5deb3';
                const plazaSize = 45 * scale;
                ctx.fillRect(size/2 - plazaSize/2, size/2 - plazaSize/2, plazaSize, plazaSize);
                
                // ê¸¸
                ctx.fillStyle = '#d2b48c';
                ctx.fillRect(0, size/2 - 2, size, 4);
                ctx.fillRect(size/2 - 2, 0, 4, size);
                
                // ê±´ë¬¼ë“¤
                ctx.fillStyle = '#ff9aa2';
                this.buildings.forEach(building => {
                    const bx = (building.position.x / this.villageSize + 0.5) * size;
                    const bz = (building.position.z / this.villageSize + 0.5) * size;
                    ctx.beginPath();
                    ctx.arc(bx, bz, 5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // ğŸ‘¾ ìŠ¬ë¼ì„ ëª¬ìŠ¤í„°
                ctx.fillStyle = '#00ff00';
                this.monsters.forEach(monster => {
                    const mx = (monster.position.x / this.villageSize + 0.5) * size;
                    const mz = (monster.position.z / this.villageSize + 0.5) * size;
                    ctx.beginPath();
                    ctx.arc(mx, mz, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#00aa00';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
                
                // í”Œë ˆì´ì–´
                const playerX = (this.player.position.x / this.villageSize + 0.5) * size;
                const playerZ = (this.player.position.z / this.villageSize + 0.5) * size;
                
                const colors = {
                    ryan: '#ffb84d',
                    muzi: '#ffeb3b',
                    apeach: '#ffb3d9'
                };
                
                ctx.fillStyle = colors[this.currentCharacter];
                ctx.beginPath();
                ctx.arc(playerX, playerZ, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.time += 0.01;
                this.updatePlayer();
                this.updateCamera();
                this.updateMinimap();
                this.animateCharacter(); // ìºë¦­í„° ì• ë‹ˆë©”ì´ì…˜
                this.updateBullets(); // ğŸ”« ì´ì•Œ ì—…ë°ì´íŠ¸
                this.checkCollisions(); // ğŸ’¥ ì¶©ëŒ ê°ì§€

                this.renderer.render(this.scene, this.camera);
            }
        }

        const game = new CozyVillageGame();
        window.game = game; // ì „ì—­ ì ‘ê·¼ (ëª¨ë¸ ì‚­ì œìš©)
        
        console.log('ğŸ—ï¸ Revit ë¹Œë¦¬ì§€ ì–¼í‹°ë°‹ - BIM ë©”íƒ€ë²„ìŠ¤ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!');
    </script>
</body>
</html>
